#pragma version 10

// This TEAL was generated by TEALScript v0.90.0
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
int 6
*
txn OnCompletion
+
switch *call_NoOp *call_OptIn *call_CloseOut *NOT_IMPLEMENTED *call_UpdateApplication *call_DeleteApplication *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	err

// onlyOwner(): void
//
// Assert the transaction sender is the owner of the contract.
onlyOwner:
	proto 0 0

	// src/roles/Ownable.algo.ts:53
	// assert(this.txn.sender === this._owner.value, 'SENDER_NOT_ALLOWED')
	txn Sender
	byte 0x5f6f776e6572 // "_owner"
	app_global_get
	==

	// SENDER_NOT_ALLOWED
	assert
	retsub

// isOwner(): boolean
//
// Checks if the current transaction sender is the owner.
// @returns boolean True if the sender is the owner, false otherwise.
isOwner:
	proto 0 1

	// src/roles/Ownable.algo.ts:61
	// return this.txn.sender === this._owner.value;
	txn Sender
	byte 0x5f6f776e6572 // "_owner"
	app_global_get
	==
	retsub

// owner()address
*abi_route_owner:
	// The ABI return prefix
	byte 0x151f7c75

	// execute owner()address
	callsub owner
	concat
	log
	int 1
	return

// owner(): Address
owner:
	proto 0 1

	// src/roles/Ownable.algo.ts:67
	// return this._owner.value;
	byte 0x5f6f776e6572 // "_owner"
	app_global_get
	retsub

// _transferOwnership(newOwner: Address): void
//
// Transfers the ownership of the contract to a new owner.
// @param newOwner The address of the new owner.
_transferOwnership:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/roles/Ownable.algo.ts:76
	// previousOwner = this._owner.exists ? this._owner.value : globals.zeroAddress
	txna Applications 0
	byte 0x5f6f776e6572 // "_owner"
	app_global_get_ex
	swap
	pop
	bz *ternary1_false
	byte 0x5f6f776e6572 // "_owner"
	app_global_get
	b *ternary1_end

*ternary1_false:
	global ZeroAddress

*ternary1_end:
	frame_bury 0 // previousOwner: address

	// src/roles/Ownable.algo.ts:77
	// this._owner.value = newOwner
	byte 0x5f6f776e6572 // "_owner"
	frame_dig -1 // newOwner: Address
	app_global_put

	// src/roles/Ownable.algo.ts:79
	// this.OwnershipTransferred.log({
	//             previousOwner: previousOwner,
	//             newOwner: newOwner,
	//         })
	byte 0x9a223efb // OwnershipTransferred(address,address)
	frame_dig 0 // previousOwner: address
	frame_dig -1 // newOwner: Address
	concat
	concat
	log
	retsub

// transferOwnership(address)void
*abi_route_transferOwnership:
	// newOwner: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute transferOwnership(address)void
	callsub transferOwnership
	int 1
	return

// transferOwnership(newOwner: Address): void
//
// Transfers the ownership of the contract to a new owner.
// Requires the caller to be the current owner.
//
// @param newOwner The address of the new owner.
transferOwnership:
	proto 1 0

	// src/roles/Ownable.algo.ts:93
	// this.onlyOwner()
	callsub onlyOwner

	// src/roles/Ownable.algo.ts:95
	// this._transferOwnership(newOwner)
	frame_dig -1 // newOwner: Address
	callsub _transferOwnership
	retsub

// whenNotPaused(): void
//
// @dev Modifier to make a function callable only when the contract is not paused.
whenNotPaused:
	proto 0 0

	// src/roles/Pausable.algo.ts:49
	// assert(!this.paused.value)
	byte 0x706175736564 // "paused"
	app_global_get
	int 0
	getbit
	!
	assert
	retsub

// onlyPauser(): void
//
// @dev throws if called by any account other than the pauser
onlyPauser:
	proto 0 0

	// src/roles/Pausable.algo.ts:56
	// assert(this.txn.sender === this._pauser.value)
	txn Sender
	byte 0x5f706175736572 // "_pauser"
	app_global_get
	==
	assert
	retsub

// pauser()address
*abi_route_pauser:
	// The ABI return prefix
	byte 0x151f7c75

	// execute pauser()address
	callsub pauser
	concat
	log
	int 1
	return

// pauser(): Address
//
// @notice Returns current pauser
// @return Pauser's address
pauser:
	proto 0 1

	// src/roles/Pausable.algo.ts:65
	// return this._pauser.value;
	byte 0x5f706175736572 // "_pauser"
	app_global_get
	retsub

// pause()void
*abi_route_pause:
	// execute pause()void
	callsub pause
	int 1
	return

// pause(): void
//
// @dev called by the owner to pause, triggers stopped state
pause:
	proto 0 0

	// src/roles/Pausable.algo.ts:73
	// this.onlyPauser()
	callsub onlyPauser

	// src/roles/Pausable.algo.ts:75
	// this.paused.value = true
	byte 0x706175736564 // "paused"
	int 1
	byte 0x00
	int 0
	uncover 2
	setbit
	app_global_put

	// src/roles/Pausable.algo.ts:76
	// this.Pause.log({})
	byte 0xcf23a30f // Pause()
	concat
	log
	retsub

// unpause()void
*abi_route_unpause:
	// execute unpause()void
	callsub unpause
	int 1
	return

// unpause(): void
//
// @dev called by the owner to unpause, returns to normal state
unpause:
	proto 0 0

	// src/roles/Pausable.algo.ts:83
	// this.onlyPauser()
	callsub onlyPauser

	// src/roles/Pausable.algo.ts:85
	// this.paused.value = false
	byte 0x706175736564 // "paused"
	int 0
	byte 0x00
	int 0
	uncover 2
	setbit
	app_global_put

	// src/roles/Pausable.algo.ts:86
	// this.Unpause.log({})
	byte 0xb163ee0b // Unpause()
	concat
	log
	retsub

// updatePauser(address)void
*abi_route_updatePauser:
	// _newPauser: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute updatePauser(address)void
	callsub updatePauser
	int 1
	return

// updatePauser(_newPauser: Address): void
//
// @dev update the pauser role
updatePauser:
	proto 1 0

	// src/roles/Pausable.algo.ts:93
	// this.onlyPauser()
	callsub onlyPauser

	// src/roles/Pausable.algo.ts:95
	// assert(_newPauser !== globals.zeroAddress)
	frame_dig -1 // _newPauser: Address
	global ZeroAddress
	!=
	assert

	// src/roles/Pausable.algo.ts:96
	// this._pauser.value = _newPauser
	byte 0x5f706175736572 // "_pauser"
	frame_dig -1 // _newPauser: Address
	app_global_put

	// src/roles/Pausable.algo.ts:97
	// this.PauserChanged.log({ newAddress: this._pauser.value })
	byte 0xcc40923c // PauserChanged(address)
	byte 0x5f706175736572 // "_pauser"
	app_global_get
	concat
	log
	retsub

// isCardFundOwner(cardFund: Address): boolean
//
// Check if the current transaction sender is the Card Fund holder/owner
// @param cardFund Card Fund address
// @returns True if the sender is the Card Holder of the card
isCardFundOwner:
	proto 1 1

	// src/Immersve.algo.ts:269
	// assert(this.card_funds(cardFund).exists, 'CARD_FUND_NOT_FOUND')
	byte 0x6366 // "cf"
	frame_dig -1 // cardFund: Address
	concat
	box_len
	swap
	pop

	// CARD_FUND_NOT_FOUND
	assert

	// src/Immersve.algo.ts:270
	// return this.card_funds(cardFund).value.owner === this.txn.sender;
	int 32 // headOffset
	int 32
	byte 0x6366 // "cf"
	frame_dig -1 // cardFund: Address
	concat
	cover 2
	box_extract
	txn Sender
	==
	retsub

// cardFundAssetOptIn(cardFund: Address, asset: AssetID): void
//
// Opt-in a Card Fund into an asset. Minimum balance requirement must be met prior to calling this function.
// @param cardFund Card Fund address
// @param asset Asset to opt-in to
cardFundAssetOptIn:
	proto 2 0

	// src/Immersve.algo.ts:280
	// assert(this.app.address.isOptedInToAsset(asset), 'ASSET_NOT_OPTED_IN')
	global CurrentApplicationAddress
	frame_dig -2 // asset: AssetID
	asset_holding_get AssetBalance
	swap
	pop

	// ASSET_NOT_OPTED_IN
	assert

	// src/Immersve.algo.ts:282
	// sendAssetTransfer({
	//             sender: cardFund,
	//             assetReceiver: cardFund,
	//             xferAsset: asset,
	//             assetAmount: 0,
	//         })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// src/Immersve.algo.ts:283
	// sender: cardFund
	frame_dig -1 // cardFund: Address
	itxn_field Sender

	// src/Immersve.algo.ts:284
	// assetReceiver: cardFund
	frame_dig -1 // cardFund: Address
	itxn_field AssetReceiver

	// src/Immersve.algo.ts:285
	// xferAsset: asset
	frame_dig -2 // asset: AssetID
	itxn_field XferAsset

	// src/Immersve.algo.ts:286
	// assetAmount: 0
	int 0
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/Immersve.algo.ts:289
	// this.CardFundAssetEnabled.log({
	//             cardFund: cardFund,
	//             asset: asset,
	//         })
	byte 0x248a051e // CardFundAssetEnabled(address,uint64)
	frame_dig -1 // cardFund: Address
	frame_dig -2 // asset: AssetID
	itob
	concat
	concat
	log
	retsub

// cardFundAssetCloseOut(cardFund: Address, asset: AssetID): void
cardFundAssetCloseOut:
	proto 2 0

	// src/Immersve.algo.ts:296
	// sendAssetTransfer({
	//             sender: cardFund,
	//             assetReceiver: cardFund,
	//             assetCloseTo: cardFund,
	//             xferAsset: asset,
	//             assetAmount: 0,
	//         })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// src/Immersve.algo.ts:297
	// sender: cardFund
	frame_dig -1 // cardFund: Address
	itxn_field Sender

	// src/Immersve.algo.ts:298
	// assetReceiver: cardFund
	frame_dig -1 // cardFund: Address
	itxn_field AssetReceiver

	// src/Immersve.algo.ts:299
	// assetCloseTo: cardFund
	frame_dig -1 // cardFund: Address
	itxn_field AssetCloseTo

	// src/Immersve.algo.ts:300
	// xferAsset: asset
	frame_dig -2 // asset: AssetID
	itxn_field XferAsset

	// src/Immersve.algo.ts:301
	// assetAmount: 0
	int 0
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/Immersve.algo.ts:304
	// sendPayment({
	//             sender: cardFund,
	//             receiver: this.txn.sender,
	//             amount: globals.assetOptInMinBalance,
	//         })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// src/Immersve.algo.ts:305
	// sender: cardFund
	frame_dig -1 // cardFund: Address
	itxn_field Sender

	// src/Immersve.algo.ts:306
	// receiver: this.txn.sender
	txn Sender
	itxn_field Receiver

	// src/Immersve.algo.ts:307
	// amount: globals.assetOptInMinBalance
	global AssetOptInMinBalance
	itxn_field Amount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/Immersve.algo.ts:310
	// this.CardFundAssetDisabled.log({
	//             cardFund: cardFund,
	//             asset: asset,
	//         })
	byte 0xd1531678 // CardFundAssetDisabled(address,uint64)
	frame_dig -1 // cardFund: Address
	frame_dig -2 // asset: AssetID
	itob
	concat
	concat
	log
	retsub

// withdrawFunds(withdrawal: WithdrawalRequest): void
withdrawFunds:
	proto 1 0

	// src/Immersve.algo.ts:317
	// sendAssetTransfer({
	//             sender: withdrawal.cardFund,
	//             assetReceiver: withdrawal.recipient,
	//             xferAsset: withdrawal.asset,
	//             assetAmount: withdrawal.amount,
	//         })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// src/Immersve.algo.ts:318
	// sender: withdrawal.cardFund
	frame_dig -1 // withdrawal: WithdrawalRequest
	extract 0 32
	itxn_field Sender

	// src/Immersve.algo.ts:319
	// assetReceiver: withdrawal.recipient
	frame_dig -1 // withdrawal: WithdrawalRequest
	extract 32 32
	itxn_field AssetReceiver

	// src/Immersve.algo.ts:320
	// xferAsset: withdrawal.asset
	frame_dig -1 // withdrawal: WithdrawalRequest
	extract 64 8
	btoi
	itxn_field XferAsset

	// src/Immersve.algo.ts:321
	// assetAmount: withdrawal.amount
	frame_dig -1 // withdrawal: WithdrawalRequest
	extract 72 8
	btoi
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/Immersve.algo.ts:325
	// this.Withdrawal.log({
	//             cardFund: withdrawal.cardFund,
	//             recipient: withdrawal.recipient,
	//             asset: withdrawal.asset,
	//             amount: withdrawal.amount,
	//             nonce: withdrawal.nonce,
	//         })
	byte 0x3b7b360b // Withdrawal(address,address,uint64,uint64,uint64)
	frame_dig -1 // withdrawal: WithdrawalRequest
	extract 0 32
	frame_dig -1 // withdrawal: WithdrawalRequest
	extract 32 32
	concat
	frame_dig -1 // withdrawal: WithdrawalRequest
	extract 64 8
	btoi
	itob
	concat
	frame_dig -1 // withdrawal: WithdrawalRequest
	extract 72 8
	btoi
	itob
	concat
	frame_dig -1 // withdrawal: WithdrawalRequest
	extract 88 8
	btoi
	itob
	concat
	concat
	log
	retsub

// updateSettlementAddress(asset: AssetID, newSettlementAddress: Address): void
updateSettlementAddress:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/Immersve.algo.ts:335
	// oldSettlementAddress = this.settlement_address(asset).exists
	//             ? this.settlement_address(asset).value
	//             : globals.zeroAddress
	byte 0x7361 // "sa"
	frame_dig -1 // asset: AssetID
	itob
	concat
	box_len
	swap
	pop
	bz *ternary3_false
	byte 0x7361 // "sa"
	frame_dig -1 // asset: AssetID
	itob
	concat
	box_get
	assert
	b *ternary3_end

*ternary3_false:
	global ZeroAddress

*ternary3_end:
	frame_bury 0 // oldSettlementAddress: address

	// src/Immersve.algo.ts:338
	// this.settlement_address(asset).value = newSettlementAddress
	byte 0x7361 // "sa"
	frame_dig -1 // asset: AssetID
	itob
	concat
	frame_dig -2 // newSettlementAddress: Address
	box_put

	// src/Immersve.algo.ts:340
	// this.SettlementAddressChanged.log({
	//             oldSettlementAddress: oldSettlementAddress,
	//             newSettlementAddress: newSettlementAddress,
	//         })
	byte 0xfd535358 // SettlementAddressChanged(address,address)
	frame_dig 0 // oldSettlementAddress: address
	frame_dig -2 // newSettlementAddress: Address
	concat
	concat
	log
	retsub

// deploy(address)address
*abi_route_deploy:
	// The ABI return prefix
	byte 0x151f7c75

	// owner: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute deploy(address)address
	callsub deploy
	concat
	log
	int 1
	return

// deploy(owner: Address): Address
//
// Deploy a partner channel, setting the owner as provided
deploy:
	proto 1 1

	// src/Immersve.algo.ts:352
	// this._transferOwnership(owner)
	frame_dig -1 // owner: Address
	callsub _transferOwnership

	// src/Immersve.algo.ts:354
	// return this.app.address;
	global CurrentApplicationAddress
	retsub

// update()void
*abi_route_update:
	// execute update()void
	callsub update
	int 1
	return

// update(): void
//
// Allows the owner to update the smart contract
update:
	proto 0 0

	// src/Immersve.algo.ts:362
	// this.onlyOwner()
	callsub onlyOwner
	retsub

// destroy()void
*abi_route_destroy:
	// execute destroy()void
	callsub destroy
	int 1
	return

// destroy(): void
//
// Destroy the smart contract, sending all Algo to the owner account. This can only be done if there are no active card funds
destroy:
	proto 0 0

	// src/Immersve.algo.ts:370
	// this.onlyOwner()
	callsub onlyOwner

	// src/Immersve.algo.ts:373
	// assert(!this.card_funds_active_count.value, 'CARD_FUNDS_STILL_ACTIVE')
	byte 0x63666163 // "cfac"
	app_global_get
	!

	// CARD_FUNDS_STILL_ACTIVE
	assert

	// src/Immersve.algo.ts:375
	// assert(!this.partner_channels_active_count.value, 'PARTNER_CHANNELS_STILL_ACTIVE')
	byte 0x70636163 // "pcac"
	app_global_get
	!

	// PARTNER_CHANNELS_STILL_ACTIVE
	assert

	// src/Immersve.algo.ts:377
	// sendPayment({
	//             receiver: this.app.address,
	//             amount: 0,
	//             closeRemainderTo: this.owner(),
	//         })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// src/Immersve.algo.ts:378
	// receiver: this.app.address
	global CurrentApplicationAddress
	itxn_field Receiver

	// src/Immersve.algo.ts:379
	// amount: 0
	int 0
	itxn_field Amount

	// src/Immersve.algo.ts:380
	// closeRemainderTo: this.owner()
	callsub owner
	itxn_field CloseRemainderTo

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// setWithdrawalTimeout(uint64)void
*abi_route_setWithdrawalTimeout:
	// seconds: uint64
	txna ApplicationArgs 1
	btoi

	// execute setWithdrawalTimeout(uint64)void
	callsub setWithdrawalTimeout
	int 1
	return

// setWithdrawalTimeout(seconds: uint64): void
//
// Set the number of seconds a withdrawal request must wait until being withdrawn
// @param seconds New number of seconds to wait
setWithdrawalTimeout:
	proto 1 0

	// src/Immersve.algo.ts:390
	// this.onlyOwner()
	callsub onlyOwner

	// src/Immersve.algo.ts:392
	// this.withdrawal_wait_time.value = seconds
	byte 0x777774 // "wwt"
	frame_dig -1 // seconds: uint64
	app_global_put
	retsub

// setEarlyWithdrawalPubkey(byte[32])void
*abi_route_setEarlyWithdrawalPubkey:
	// pubkey: byte[32]
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute setEarlyWithdrawalPubkey(byte[32])void
	callsub setEarlyWithdrawalPubkey
	int 1
	return

// setEarlyWithdrawalPubkey(pubkey: bytes32): void
//
// Sets the early withdrawal public key.
// @param pubkey - The public key to set.
setEarlyWithdrawalPubkey:
	proto 1 0

	// src/Immersve.algo.ts:400
	// this.onlyOwner()
	callsub onlyOwner

	// src/Immersve.algo.ts:402
	// this.early_withdrawal_pubkey.value = pubkey
	byte 0x6577706b // "ewpk"
	frame_dig -1 // pubkey: bytes32
	app_global_put
	retsub

// partnerChannelCreate(pay,string)address
*abi_route_partnerChannelCreate:
	// The ABI return prefix
	byte 0x151f7c75

	// partnerChannelName: string
	txna ApplicationArgs 1
	extract 2 0

	// mbr: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==
	assert

	// execute partnerChannelCreate(pay,string)address
	callsub partnerChannelCreate
	concat
	log
	int 1
	return

// partnerChannelCreate(mbr: PayTxn, partnerChannelName: string): Address
//
// Creates a partner channel account and associates it with the provided partner channel name.
// Only the owner of the contract can call this function.
//
// @param mbr - The PayTxn object representing the payment transaction.
// @param partnerChannelName - The name of the partner channel.
// @returns The address of the newly created partner channel account.
partnerChannelCreate:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// src/Immersve.algo.ts:414
	// boxCost = 2500 + 400 * (3 + 32 + len(partnerChannelName))
	int 2500
	int 400
	int 35
	frame_dig -2 // partnerChannelName: string
	len
	+
	*
	+
	frame_bury 0 // boxCost: uint64

	// src/Immersve.algo.ts:416
	// verifyPayTxn(mbr, {
	//             receiver: this.app.address,
	//             amount: globals.minBalance + globals.assetOptInMinBalance + boxCost,
	//         })
	// verify receiver
	frame_dig -1 // mbr: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==
	assert

	// verify amount
	frame_dig -1 // mbr: PayTxn
	gtxns Amount
	global MinBalance
	global AssetOptInMinBalance
	+
	frame_dig 0 // boxCost: uint64
	+
	==
	assert

	// src/Immersve.algo.ts:422
	// partnerChannelAddr = sendMethodCall<typeof ControlledAddress.prototype.new>({
	//             onCompletion: OnCompletion.DeleteApplication,
	//             approvalProgram: ControlledAddress.approvalProgram(),
	//             clearStateProgram: ControlledAddress.clearProgram(),
	//         })
	itxn_begin
	int appl
	itxn_field TypeEnum
	method "new()address"
	itxn_field ApplicationArgs

	// src/Immersve.algo.ts:423
	// onCompletion: OnCompletion.DeleteApplication
	int 5 // DeleteApplication
	itxn_field OnCompletion

	// src/Immersve.algo.ts:424
	// approvalProgram: ControlledAddress.approvalProgram()
	byte b64 CiACAQAxGBSBBgsxGQiNDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJwCABBUffHWIAARQsCJDigABsSKyEDIKsgcjsggyDrIgI7IBszIKiYAEVh0v6jYaAI4B/80A
	itxn_field ApprovalProgram

	// src/Immersve.algo.ts:425
	// clearStateProgram: ControlledAddress.clearProgram()
	byte b64 Cg==
	itxn_field ClearStateProgram

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	int 1
	-
	itxnas Logs
	extract 4 0
	frame_bury 1 // partnerChannelAddr: address

	// src/Immersve.algo.ts:429
	// sendPayment({
	//             receiver: partnerChannelAddr,
	//             amount: globals.minBalance,
	//         })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// src/Immersve.algo.ts:430
	// receiver: partnerChannelAddr
	frame_dig 1 // partnerChannelAddr: address
	itxn_field Receiver

	// src/Immersve.algo.ts:431
	// amount: globals.minBalance
	global MinBalance
	itxn_field Amount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/Immersve.algo.ts:434
	// this.partner_channels(partnerChannelAddr).value = partnerChannelName
	byte 0x7063 // "pc"
	frame_dig 1 // partnerChannelAddr: address
	concat
	dup
	box_del
	pop
	frame_dig -2 // partnerChannelName: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	box_put

	// src/Immersve.algo.ts:437
	// this.partner_channels_active_count.value = this.partner_channels_active_count.value + 1
	byte 0x70636163 // "pcac"
	dup
	app_global_get
	int 1
	+
	app_global_put

	// src/Immersve.algo.ts:439
	// this.PartnerChannelCreated.log({
	//             partnerChannel: partnerChannelAddr,
	//             partnerChannelName: partnerChannelName,
	//         })
	byte 0x2c924dee // PartnerChannelCreated(address,string)
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x0022 // initial head offset
	frame_dig 1 // partnerChannelAddr: address
	callsub *process_static_tuple_element
	frame_dig -2 // partnerChannelName: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	concat
	log

	// src/Immersve.algo.ts:444
	// return partnerChannelAddr;
	frame_dig 1 // partnerChannelAddr: address

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// partnerChannelClose(address)void
*abi_route_partnerChannelClose:
	// partnerChannel: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute partnerChannelClose(address)void
	callsub partnerChannelClose
	int 1
	return

// partnerChannelClose(partnerChannel: Address): void
partnerChannelClose:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// src/Immersve.algo.ts:448
	// this.onlyOwner()
	callsub onlyOwner

	// src/Immersve.algo.ts:450
	// sendPayment({
	//             sender: partnerChannel,
	//             receiver: partnerChannel,
	//             amount: 0,
	//             closeRemainderTo: this.txn.sender,
	//         })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// src/Immersve.algo.ts:451
	// sender: partnerChannel
	frame_dig -1 // partnerChannel: Address
	itxn_field Sender

	// src/Immersve.algo.ts:452
	// receiver: partnerChannel
	frame_dig -1 // partnerChannel: Address
	itxn_field Receiver

	// src/Immersve.algo.ts:453
	// amount: 0
	int 0
	itxn_field Amount

	// src/Immersve.algo.ts:454
	// closeRemainderTo: this.txn.sender
	txn Sender
	itxn_field CloseRemainderTo

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/Immersve.algo.ts:457
	// partnerChannelSize = this.partner_channels(partnerChannel).size
	byte 0x7063 // "pc"
	frame_dig -1 // partnerChannel: Address
	concat
	box_len
	assert
	frame_bury 0 // partnerChannelSize: uint64

	// src/Immersve.algo.ts:458
	// boxCost = 2500 + 400 * (3 + 32 + partnerChannelSize)
	int 2500
	int 400
	int 35
	frame_dig 0 // partnerChannelSize: uint64
	+
	*
	+
	frame_bury 1 // boxCost: uint64

	// src/Immersve.algo.ts:460
	// sendPayment({
	//             receiver: this.txn.sender,
	//             amount: boxCost,
	//         })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// src/Immersve.algo.ts:461
	// receiver: this.txn.sender
	txn Sender
	itxn_field Receiver

	// src/Immersve.algo.ts:462
	// amount: boxCost
	frame_dig 1 // boxCost: uint64
	itxn_field Amount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/Immersve.algo.ts:466
	// this.partner_channels(partnerChannel).delete()
	byte 0x7063 // "pc"
	frame_dig -1 // partnerChannel: Address
	concat
	box_del

	// src/Immersve.algo.ts:469
	// this.partner_channels_active_count.value = this.partner_channels_active_count.value - 1
	byte 0x70636163 // "pcac"
	dup
	app_global_get
	int 1
	-
	app_global_put
	retsub

// cardFundCreate(pay,address,uint64)address
*abi_route_cardFundCreate:
	// The ABI return prefix
	byte 0x151f7c75

	// asset: uint64
	txna ApplicationArgs 2
	btoi

	// partnerChannel: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// mbr: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==
	assert

	// execute cardFundCreate(pay,address,uint64)address
	callsub cardFundCreate
	concat
	log
	int 1
	return

// cardFundCreate(mbr: PayTxn, partnerChannel: Address, asset: AssetID): Address
//
// Create account. This generates a brand new account and funds the minimum balance requirement
// @param mbr Payment transaction of minimum balance requirement
// @param partnerChannel Funding Channel name
// @param asset Asset to opt-in to. 0 = No asset opt-in
// @returns Newly generated account used by their card
cardFundCreate:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 3

	// src/Immersve.algo.ts:480
	// assert(this.partner_channels(partnerChannel).exists, 'PARTNER_CHANNEL_NOT_FOUND')
	byte 0x7063 // "pc"
	frame_dig -2 // partnerChannel: Address
	concat
	box_len
	swap
	pop

	// PARTNER_CHANNEL_NOT_FOUND
	assert

	// src/Immersve.algo.ts:482
	// cardFundData: CardFundData = {
	//             partnerChannel: partnerChannel,
	//             owner: this.txn.sender,
	//             address: globals.zeroAddress,
	//             nonce: 0,
	//         }
	frame_dig -2 // partnerChannel: Address
	txn Sender
	concat
	global ZeroAddress
	concat
	byte 0x0000000000000000
	concat
	frame_bury 0 // cardFundData: CardFundData

	// src/Immersve.algo.ts:488
	// boxCost = 2500 + 400 * (3 + 32 + len(cardFundData))
	int 58100
	frame_bury 1 // boxCost: uint64

	// src/Immersve.algo.ts:489
	// assetMbr = asset ? globals.assetOptInMinBalance : 0
	frame_dig -3 // asset: AssetID
	bz *ternary5_false
	global AssetOptInMinBalance
	b *ternary5_end

*ternary5_false:
	int 0

*ternary5_end:
	frame_bury 2 // assetMbr: uint64

	// src/Immersve.algo.ts:491
	// verifyPayTxn(mbr, {
	//             receiver: this.app.address,
	//             amount: globals.minBalance + assetMbr + boxCost,
	//         })
	// verify receiver
	frame_dig -1 // mbr: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==
	assert

	// verify amount
	frame_dig -1 // mbr: PayTxn
	gtxns Amount
	global MinBalance
	frame_dig 2 // assetMbr: uint64
	+
	int 58100 // boxCost: uint64
	+
	==
	assert

	// src/Immersve.algo.ts:497
	// cardFundAddr = sendMethodCall<typeof ControlledAddress.prototype.new>({
	//             onCompletion: OnCompletion.DeleteApplication,
	//             approvalProgram: ControlledAddress.approvalProgram(),
	//             clearStateProgram: ControlledAddress.clearProgram(),
	//         })
	itxn_begin
	int appl
	itxn_field TypeEnum
	method "new()address"
	itxn_field ApplicationArgs

	// src/Immersve.algo.ts:498
	// onCompletion: OnCompletion.DeleteApplication
	int 5 // DeleteApplication
	itxn_field OnCompletion

	// src/Immersve.algo.ts:499
	// approvalProgram: ControlledAddress.approvalProgram()
	byte b64 CiACAQAxGBSBBgsxGQiNDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJwCABBUffHWIAARQsCJDigABsSKyEDIKsgcjsggyDrIgI7IBszIKiYAEVh0v6jYaAI4B/80A
	itxn_field ApprovalProgram

	// src/Immersve.algo.ts:500
	// clearStateProgram: ControlledAddress.clearProgram()
	byte b64 Cg==
	itxn_field ClearStateProgram

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	int 1
	-
	itxnas Logs
	extract 4 0
	frame_bury 3 // cardFundAddr: address

	// src/Immersve.algo.ts:504
	// cardFundData.address = cardFundAddr
	frame_dig 0 // cardFundData: CardFundData
	int 64 // headOffset
	frame_dig 3 // cardFundAddr: address
	replace3
	frame_bury 0 // cardFundData: CardFundData

	// src/Immersve.algo.ts:507
	// sendPayment({
	//             receiver: cardFundAddr,
	//             amount: globals.minBalance + assetMbr,
	//         })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// src/Immersve.algo.ts:508
	// receiver: cardFundAddr
	frame_dig 3 // cardFundAddr: address
	itxn_field Receiver

	// src/Immersve.algo.ts:509
	// amount: globals.minBalance + assetMbr
	global MinBalance
	frame_dig 2 // assetMbr: uint64
	+
	itxn_field Amount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// *if0_condition
	// src/Immersve.algo.ts:513
	// asset
	frame_dig -3 // asset: AssetID
	bz *if0_end

	// *if0_consequent
	// src/Immersve.algo.ts:514
	// this.cardFundAssetOptIn(cardFundAddr, asset)
	frame_dig -3 // asset: AssetID
	frame_dig 3 // cardFundAddr: address
	callsub cardFundAssetOptIn

*if0_end:
	// src/Immersve.algo.ts:518
	// this.card_funds(cardFundAddr).value = cardFundData
	byte 0x6366 // "cf"
	frame_dig 3 // cardFundAddr: address
	concat
	frame_dig 0 // cardFundData: CardFundData
	box_put

	// src/Immersve.algo.ts:521
	// this.card_funds_active_count.value = this.card_funds_active_count.value + 1
	byte 0x63666163 // "cfac"
	dup
	app_global_get
	int 1
	+
	app_global_put

	// src/Immersve.algo.ts:523
	// this.CardFundCreated.log({
	//             cardFundOwner: this.txn.sender,
	//             cardFund: cardFundAddr,
	//             partnerChannel: partnerChannel,
	//         })
	byte 0xb4895e47 // CardFundCreated(address,address,address)
	txn Sender
	frame_dig 3 // cardFundAddr: address
	concat
	frame_dig -2 // partnerChannel: Address
	concat
	concat
	log

	// src/Immersve.algo.ts:530
	// return cardFundAddr;
	frame_dig 3 // cardFundAddr: address

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 3
	retsub

// cardFundClose(address)void
*abi_route_cardFundClose:
	// cardFund: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute cardFundClose(address)void
	callsub cardFundClose
	int 1
	return

// cardFundClose(cardFund: Address): void
//
// Close account. This permanently removes the rekey and deletes the account from the ledger
// @param cardFund Address to close
cardFundClose:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// src/Immersve.algo.ts:538
	// assert(this.isOwner() || this.isCardFundOwner(cardFund), 'SENDER_NOT_ALLOWED')
	callsub isOwner
	dup
	bnz *skip_or0
	frame_dig -1 // cardFund: Address
	callsub isCardFundOwner
	||

*skip_or0:
	// SENDER_NOT_ALLOWED
	assert

	// src/Immersve.algo.ts:540
	// sendPayment({
	//             sender: cardFund,
	//             receiver: cardFund,
	//             amount: 0,
	//             closeRemainderTo: this.txn.sender,
	//         })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// src/Immersve.algo.ts:541
	// sender: cardFund
	frame_dig -1 // cardFund: Address
	itxn_field Sender

	// src/Immersve.algo.ts:542
	// receiver: cardFund
	frame_dig -1 // cardFund: Address
	itxn_field Receiver

	// src/Immersve.algo.ts:543
	// amount: 0
	int 0
	itxn_field Amount

	// src/Immersve.algo.ts:544
	// closeRemainderTo: this.txn.sender
	txn Sender
	itxn_field CloseRemainderTo

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/Immersve.algo.ts:547
	// cardFundSize = this.card_funds(cardFund).size
	byte 0x6366 // "cf"
	frame_dig -1 // cardFund: Address
	concat
	box_len
	assert
	frame_bury 0 // cardFundSize: uint64

	// src/Immersve.algo.ts:548
	// boxCost = 2500 + 400 * (1 + cardFundSize + 32)
	int 2500
	int 400
	int 1
	frame_dig 0 // cardFundSize: uint64
	+
	int 32
	+
	*
	+
	frame_bury 1 // boxCost: uint64

	// src/Immersve.algo.ts:550
	// sendPayment({
	//             receiver: this.txn.sender,
	//             amount: boxCost,
	//         })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// src/Immersve.algo.ts:551
	// receiver: this.txn.sender
	txn Sender
	itxn_field Receiver

	// src/Immersve.algo.ts:552
	// amount: boxCost
	frame_dig 1 // boxCost: uint64
	itxn_field Amount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/Immersve.algo.ts:556
	// this.card_funds(cardFund).delete()
	byte 0x6366 // "cf"
	frame_dig -1 // cardFund: Address
	concat
	box_del

	// src/Immersve.algo.ts:559
	// this.card_funds_active_count.value = this.card_funds_active_count.value - 1
	byte 0x63666163 // "cfac"
	dup
	app_global_get
	int 1
	-
	app_global_put
	retsub

// cardFundRecover(address,address)void
*abi_route_cardFundRecover:
	// newCardFundHolder: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// cardFund: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute cardFundRecover(address,address)void
	callsub cardFundRecover
	int 1
	return

// cardFundRecover(cardFund: Address, newCardFundHolder: Address): void
//
// Recovers funds from an old card and transfers them to a new card.
// Only the owner of the contract can perform this operation.
//
// @param cardFund - The card fund to recover.
// @param newCardFundHolder - The address of the new card holder.
cardFundRecover:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/Immersve.algo.ts:570
	// this.onlyOwner()
	callsub onlyOwner

	// src/Immersve.algo.ts:573
	// oldCardFundHolder = this.card_funds(cardFund).value.owner
	int 32 // headOffset
	int 32
	byte 0x6366 // "cf"
	frame_dig -1 // cardFund: Address
	concat
	cover 2
	box_extract
	frame_bury 0 // oldCardFundHolder: address

	// src/Immersve.algo.ts:574
	// this.card_funds(cardFund).value.owner = newCardFundHolder
	int 32 // headOffset
	frame_dig -2 // newCardFundHolder: Address
	byte 0x6366 // "cf"
	frame_dig -1 // cardFund: Address
	concat
	cover 2
	box_replace
	retsub

// assetAllowlistAdd(pay,uint64,address)void
*abi_route_assetAllowlistAdd:
	// settlementAddress: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// asset: uint64
	txna ApplicationArgs 1
	btoi

	// mbr: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==
	assert

	// execute assetAllowlistAdd(pay,uint64,address)void
	callsub assetAllowlistAdd
	int 1
	return

// assetAllowlistAdd(mbr: PayTxn, asset: AssetID, settlementAddress: Address): void
//
// Allows the master contract to flag intent of accepting an asset.
//
// @param mbr Payment transaction of minimum balance requirement.
// @param asset The AssetID of the asset being transferred.
assetAllowlistAdd:
	proto 3 0

	// src/Immersve.algo.ts:586
	// this.onlyOwner()
	callsub onlyOwner

	// src/Immersve.algo.ts:588
	// verifyPayTxn(mbr, {
	//             receiver: this.app.address,
	//             amount: globals.assetOptInMinBalance + ASSET_SETTLEMENT_ADDRESS_COST,
	//         })
	// verify receiver
	frame_dig -1 // mbr: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==
	assert

	// verify amount
	frame_dig -1 // mbr: PayTxn
	gtxns Amount
	global AssetOptInMinBalance
	int 19300
	+
	==
	assert

	// src/Immersve.algo.ts:593
	// sendAssetTransfer({
	//             sender: this.app.address,
	//             assetReceiver: this.app.address,
	//             xferAsset: asset,
	//             assetAmount: 0,
	//         })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// src/Immersve.algo.ts:594
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// src/Immersve.algo.ts:595
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// src/Immersve.algo.ts:596
	// xferAsset: asset
	frame_dig -2 // asset: AssetID
	itxn_field XferAsset

	// src/Immersve.algo.ts:597
	// assetAmount: 0
	int 0
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/Immersve.algo.ts:600
	// this.AssetAllowlistAdded.log({ asset: asset })
	byte 0x2636bc7e // AssetAllowlistAdded(uint64)
	frame_dig -2 // asset: AssetID
	itob
	concat
	log

	// src/Immersve.algo.ts:602
	// this.updateSettlementAddress(asset, settlementAddress)
	frame_dig -3 // settlementAddress: Address
	frame_dig -2 // asset: AssetID
	callsub updateSettlementAddress
	retsub

// assetAllowlistRemove(uint64)void
*abi_route_assetAllowlistRemove:
	// asset: uint64
	txna ApplicationArgs 1
	btoi

	// execute assetAllowlistRemove(uint64)void
	callsub assetAllowlistRemove
	int 1
	return

// assetAllowlistRemove(asset: AssetID): void
//
// Allows the master contract to reject accepting an asset.
//
// @param asset - The AssetID of the asset being transferred.
assetAllowlistRemove:
	proto 1 0

	// src/Immersve.algo.ts:611
	// this.onlyOwner()
	callsub onlyOwner

	// src/Immersve.algo.ts:614
	// sendAssetTransfer({
	//             sender: this.app.address,
	//             assetReceiver: this.app.address,
	//             assetCloseTo: this.app.address,
	//             xferAsset: asset,
	//             assetAmount: 0,
	//         })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// src/Immersve.algo.ts:615
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// src/Immersve.algo.ts:616
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// src/Immersve.algo.ts:617
	// assetCloseTo: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetCloseTo

	// src/Immersve.algo.ts:618
	// xferAsset: asset
	frame_dig -1 // asset: AssetID
	itxn_field XferAsset

	// src/Immersve.algo.ts:619
	// assetAmount: 0
	int 0
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/Immersve.algo.ts:623
	// this.settlement_address(asset).delete()
	byte 0x7361 // "sa"
	frame_dig -1 // asset: AssetID
	itob
	concat
	box_del

	// src/Immersve.algo.ts:625
	// sendPayment({
	//             receiver: this.txn.sender,
	//             amount: globals.assetOptInMinBalance + ASSET_SETTLEMENT_ADDRESS_COST,
	//         })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// src/Immersve.algo.ts:626
	// receiver: this.txn.sender
	txn Sender
	itxn_field Receiver

	// src/Immersve.algo.ts:627
	// amount: globals.assetOptInMinBalance + ASSET_SETTLEMENT_ADDRESS_COST
	global AssetOptInMinBalance
	int 19300
	+
	itxn_field Amount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/Immersve.algo.ts:630
	// this.AssetAllowlistRemoved.log({ asset: asset })
	byte 0x065c0374 // AssetAllowlistRemoved(uint64)
	frame_dig -1 // asset: AssetID
	itob
	concat
	log
	retsub

// cardFundDebit(address,uint64,uint64,uint64)void
*abi_route_cardFundDebit:
	// nonce: uint64
	txna ApplicationArgs 4
	btoi

	// amount: uint64
	txna ApplicationArgs 3
	btoi

	// asset: uint64
	txna ApplicationArgs 2
	btoi

	// cardFund: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute cardFundDebit(address,uint64,uint64,uint64)void
	callsub cardFundDebit
	int 1
	return

// cardFundDebit(cardFund: Address, asset: AssetID, amount: uint64, nonce: uint64): void
//
// Debits the specified amount of the given asset from the card account.
// Only the owner of the contract can perform this operation.
//
// @param cardFund The card fund from which the asset will be debited.
// @param asset The asset to be debited.
// @param amount The amount of the asset to be debited.
cardFundDebit:
	proto 4 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/Immersve.algo.ts:642
	// this.whenNotPaused()
	callsub whenNotPaused

	// src/Immersve.algo.ts:643
	// this.onlyOwner()
	callsub onlyOwner

	// src/Immersve.algo.ts:646
	// nextNonce = this.card_funds(cardFund).value.nonce
	int 96 // headOffset
	int 8
	byte 0x6366 // "cf"
	frame_dig -1 // cardFund: Address
	concat
	cover 2
	box_extract
	btoi
	frame_bury 0 // nextNonce: uint64

	// src/Immersve.algo.ts:647
	// assert(nextNonce === nonce, 'NONCE_INVALID')
	frame_dig 0 // nextNonce: uint64
	frame_dig -4 // nonce: uint64
	==

	// NONCE_INVALID
	assert

	// src/Immersve.algo.ts:649
	// sendAssetTransfer({
	//             sender: cardFund,
	//             assetReceiver: this.app.address,
	//             xferAsset: asset,
	//             assetAmount: amount,
	//         })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// src/Immersve.algo.ts:650
	// sender: cardFund
	frame_dig -1 // cardFund: Address
	itxn_field Sender

	// src/Immersve.algo.ts:651
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// src/Immersve.algo.ts:652
	// xferAsset: asset
	frame_dig -2 // asset: AssetID
	itxn_field XferAsset

	// src/Immersve.algo.ts:653
	// assetAmount: amount
	frame_dig -3 // amount: uint64
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/Immersve.algo.ts:656
	// this.Debit.log({
	//             card: cardFund,
	//             asset: asset,
	//             amount: amount,
	//             nonce: nonce,
	//         })
	byte 0x5c5b9134 // Debit(address,uint64,uint64,uint64)
	frame_dig -1 // cardFund: Address
	frame_dig -2 // asset: AssetID
	itob
	concat
	frame_dig -3 // amount: uint64
	itob
	concat
	frame_dig -4 // nonce: uint64
	itob
	concat
	concat
	log

	// src/Immersve.algo.ts:664
	// this.card_funds(cardFund).value.nonce = nextNonce + 1
	int 96 // headOffset
	frame_dig 0 // nextNonce: uint64
	int 1
	+
	itob
	byte 0x6366 // "cf"
	frame_dig -1 // cardFund: Address
	concat
	cover 2
	box_replace
	retsub

// getRefundAddress()address
*abi_route_getRefundAddress:
	// The ABI return prefix
	byte 0x151f7c75

	// execute getRefundAddress()address
	callsub getRefundAddress
	concat
	log
	int 1
	return

// getRefundAddress(): Address
//
// Retrieves the refund address.
//
// @returns The refund address.
getRefundAddress:
	proto 0 1

	// src/Immersve.algo.ts:674
	// return this.refund_address.value;
	byte 0x7261 // "ra"
	app_global_get
	retsub

// setRefundAddress(address)void
*abi_route_setRefundAddress:
	// newRefundAddress: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute setRefundAddress(address)void
	callsub setRefundAddress
	int 1
	return

// setRefundAddress(newRefundAddress: Address): void
//
// Sets the refund address.
// Only the owner of the contract can call this method.
//
// @param newRefundAddress The new refund address to be set.
setRefundAddress:
	proto 1 0

	// src/Immersve.algo.ts:684
	// this.onlyOwner()
	callsub onlyOwner

	// src/Immersve.algo.ts:686
	// this.refund_address.value = newRefundAddress
	byte 0x7261 // "ra"
	frame_dig -1 // newRefundAddress: Address
	app_global_put
	retsub

// cardFundRefund(address,uint64,uint64,uint64)void
*abi_route_cardFundRefund:
	// nonce: uint64
	txna ApplicationArgs 4
	btoi

	// amount: uint64
	txna ApplicationArgs 3
	btoi

	// asset: uint64
	txna ApplicationArgs 2
	btoi

	// cardFund: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute cardFundRefund(address,uint64,uint64,uint64)void
	callsub cardFundRefund
	int 1
	return

// cardFundRefund(cardFund: Address, asset: AssetID, amount: uint64, nonce: uint64): void
//
// Refunds a specified amount of an asset to a card account.
// Only the owner of the contract can perform this operation.
//
// @param cardFund - The card account to refund the asset to.
// @param asset - The asset to refund.
// @param amount - The amount of the asset to refund.
cardFundRefund:
	proto 4 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/Immersve.algo.ts:698
	// this.whenNotPaused()
	callsub whenNotPaused

	// src/Immersve.algo.ts:700
	// assert(this.txn.sender === this.refund_address.value, 'SENDER_NOT_ALLOWED')
	txn Sender
	byte 0x7261 // "ra"
	app_global_get
	==

	// SENDER_NOT_ALLOWED
	assert

	// src/Immersve.algo.ts:703
	// nextNonce = this.card_funds(cardFund).value.nonce
	int 96 // headOffset
	int 8
	byte 0x6366 // "cf"
	frame_dig -1 // cardFund: Address
	concat
	cover 2
	box_extract
	btoi
	frame_bury 0 // nextNonce: uint64

	// src/Immersve.algo.ts:704
	// assert(nextNonce === nonce, 'NONCE_INVALID')
	frame_dig 0 // nextNonce: uint64
	frame_dig -4 // nonce: uint64
	==

	// NONCE_INVALID
	assert

	// src/Immersve.algo.ts:706
	// sendAssetTransfer({
	//             sender: this.app.address,
	//             assetReceiver: cardFund,
	//             xferAsset: asset,
	//             assetAmount: amount,
	//         })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// src/Immersve.algo.ts:707
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// src/Immersve.algo.ts:708
	// assetReceiver: cardFund
	frame_dig -1 // cardFund: Address
	itxn_field AssetReceiver

	// src/Immersve.algo.ts:709
	// xferAsset: asset
	frame_dig -2 // asset: AssetID
	itxn_field XferAsset

	// src/Immersve.algo.ts:710
	// assetAmount: amount
	frame_dig -3 // amount: uint64
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/Immersve.algo.ts:713
	// this.Refund.log({
	//             card: cardFund,
	//             asset: asset,
	//             amount: amount,
	//             nonce: nonce,
	//         })
	byte 0xe37aae5c // Refund(address,uint64,uint64,uint64)
	frame_dig -1 // cardFund: Address
	frame_dig -2 // asset: AssetID
	itob
	concat
	frame_dig -3 // amount: uint64
	itob
	concat
	frame_dig -4 // nonce: uint64
	itob
	concat
	concat
	log

	// src/Immersve.algo.ts:721
	// this.card_funds(cardFund).value.nonce = nextNonce + 1
	int 96 // headOffset
	frame_dig 0 // nextNonce: uint64
	int 1
	+
	itob
	byte 0x6366 // "cf"
	frame_dig -1 // cardFund: Address
	concat
	cover 2
	box_replace
	retsub

// getNextSettlementNonce()uint64
*abi_route_getNextSettlementNonce:
	// The ABI return prefix
	byte 0x151f7c75

	// execute getNextSettlementNonce()uint64
	callsub getNextSettlementNonce
	itob
	concat
	log
	int 1
	return

// getNextSettlementNonce(): uint64
//
// Retrieves the next available nonce for settlements.
//
// @returns The settlement nonce.
getNextSettlementNonce:
	proto 0 1

	// src/Immersve.algo.ts:731
	// return this.settlement_nonce.value;
	byte 0x736e // "sn"
	app_global_get
	retsub

// getNextCardFundNonce(address)uint64
*abi_route_getNextCardFundNonce:
	// The ABI return prefix
	byte 0x151f7c75

	// cardFund: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute getNextCardFundNonce(address)uint64
	callsub getNextCardFundNonce
	itob
	concat
	log
	int 1
	return

// getNextCardFundNonce(cardFund: Address): uint64
//
// Retrieves the next available nonce for the card fund.
//
// @param cardFund The card fund address.
// @returns The nonce for the card fund.
getNextCardFundNonce:
	proto 1 1

	// src/Immersve.algo.ts:742
	// return this.card_funds(cardFund).value.nonce;
	int 96 // headOffset
	int 8
	byte 0x6366 // "cf"
	frame_dig -1 // cardFund: Address
	concat
	cover 2
	box_extract
	btoi
	retsub

// getCardFundData(address)(address,address,address,uint64)
*abi_route_getCardFundData:
	// The ABI return prefix
	byte 0x151f7c75

	// cardFund: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute getCardFundData(address)(address,address,address,uint64)
	callsub getCardFundData
	concat
	log
	int 1
	return

// getCardFundData(cardFund: Address): CardFundData
//
// Retrieves the card fund data for a given card fund address.
//
// @param cardFund The address of the card fund.
// @returns The card fund data.
getCardFundData:
	proto 1 1

	// src/Immersve.algo.ts:753
	// return this.card_funds(cardFund).value;
	byte 0x6366 // "cf"
	frame_dig -1 // cardFund: Address
	concat
	box_get
	assert
	retsub

// getSettlementAddress(uint64)address
*abi_route_getSettlementAddress:
	// The ABI return prefix
	byte 0x151f7c75

	// asset: uint64
	txna ApplicationArgs 1
	btoi

	// execute getSettlementAddress(uint64)address
	callsub getSettlementAddress
	concat
	log
	int 1
	return

// getSettlementAddress(asset: AssetID): Address
//
// Retrieves the settlement address for the specified asset.
//
// @param asset The ID of the asset.
// @returns The settlement address for the asset.
getSettlementAddress:
	proto 1 1

	// src/Immersve.algo.ts:764
	// return this.settlement_address(asset).value;
	byte 0x7361 // "sa"
	frame_dig -1 // asset: AssetID
	itob
	concat
	box_get
	assert
	retsub

// setSettlementAddress(uint64,address)void
*abi_route_setSettlementAddress:
	// newSettlementAddress: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// settlementAsset: uint64
	txna ApplicationArgs 1
	btoi

	// execute setSettlementAddress(uint64,address)void
	callsub setSettlementAddress
	int 1
	return

// setSettlementAddress(settlementAsset: AssetID, newSettlementAddress: Address): void
//
// Sets the settlement address for a given settlement asset.
// Only the owner of the contract can call this method.
//
// @param settlementAsset The ID of the settlement asset.
// @param newSettlementAddress The new settlement address to be set.
setSettlementAddress:
	proto 2 0

	// src/Immersve.algo.ts:775
	// this.onlyOwner()
	callsub onlyOwner

	// src/Immersve.algo.ts:777
	// this.updateSettlementAddress(settlementAsset, newSettlementAddress)
	frame_dig -2 // newSettlementAddress: Address
	frame_dig -1 // settlementAsset: AssetID
	callsub updateSettlementAddress
	retsub

// settle(uint64,uint64,uint64)void
*abi_route_settle:
	// nonce: uint64
	txna ApplicationArgs 3
	btoi

	// amount: uint64
	txna ApplicationArgs 2
	btoi

	// asset: uint64
	txna ApplicationArgs 1
	btoi

	// execute settle(uint64,uint64,uint64)void
	callsub settle
	int 1
	return

// settle(asset: AssetID, amount: uint64, nonce: uint64): void
//
// Settles a payment by transferring an asset to the specified recipient.
// Only the owner of the contract can call this function.
//
// @param asset The asset to be transferred.
// @param amount The amount of the asset to be transferred.
// @param nonce The nonce to prevent duplicate settlements.
settle:
	proto 3 0

	// src/Immersve.algo.ts:789
	// this.whenNotPaused()
	callsub whenNotPaused

	// src/Immersve.algo.ts:790
	// this.onlyOwner()
	callsub onlyOwner

	// src/Immersve.algo.ts:793
	// assert(this.settlement_nonce.value === nonce, 'NONCE_INVALID')
	byte 0x736e // "sn"
	app_global_get
	frame_dig -3 // nonce: uint64
	==

	// NONCE_INVALID
	assert

	// src/Immersve.algo.ts:795
	// sendAssetTransfer({
	//             sender: this.app.address,
	//             assetReceiver: this.settlement_address(asset).value,
	//             xferAsset: asset,
	//             assetAmount: amount,
	//         })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// src/Immersve.algo.ts:796
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// src/Immersve.algo.ts:797
	// assetReceiver: this.settlement_address(asset).value
	byte 0x7361 // "sa"
	frame_dig -1 // asset: AssetID
	itob
	concat
	box_get
	assert
	itxn_field AssetReceiver

	// src/Immersve.algo.ts:798
	// xferAsset: asset
	frame_dig -1 // asset: AssetID
	itxn_field XferAsset

	// src/Immersve.algo.ts:799
	// assetAmount: amount
	frame_dig -2 // amount: uint64
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/Immersve.algo.ts:802
	// this.Settlement.log({
	//             recipient: this.settlement_address(asset).value,
	//             asset: asset,
	//             amount: amount,
	//             nonce: nonce,
	//         })
	byte 0x558046ec // Settlement(address,uint64,uint64,uint64)
	byte 0x7361 // "sa"
	frame_dig -1 // asset: AssetID
	itob
	concat
	box_get
	assert
	frame_dig -1 // asset: AssetID
	itob
	concat
	frame_dig -2 // amount: uint64
	itob
	concat
	frame_dig -3 // nonce: uint64
	itob
	concat
	concat
	log

	// src/Immersve.algo.ts:810
	// this.settlement_nonce.value = this.settlement_nonce.value + 1
	byte 0x736e // "sn"
	dup
	app_global_get
	int 1
	+
	app_global_put
	retsub

// cardFundEnableAsset(pay,address,uint64)void
*abi_route_cardFundEnableAsset:
	// asset: uint64
	txna ApplicationArgs 2
	btoi

	// cardFund: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// mbr: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==
	assert

	// execute cardFundEnableAsset(pay,address,uint64)void
	callsub cardFundEnableAsset
	int 1
	return

// cardFundEnableAsset(mbr: PayTxn, cardFund: Address, asset: AssetID): void
//
// Allows the depositor (or owner) to OptIn to an asset, increasing the minimum balance requirement of the account
//
// @param cardFund Address to add asset to
// @param asset Asset to add
cardFundEnableAsset:
	proto 3 0

	// src/Immersve.algo.ts:821
	// assert(this.isOwner() || this.isCardFundOwner(cardFund), 'SENDER_NOT_ALLOWED')
	callsub isOwner
	dup
	bnz *skip_or1
	frame_dig -2 // cardFund: Address
	callsub isCardFundOwner
	||

*skip_or1:
	// SENDER_NOT_ALLOWED
	assert

	// src/Immersve.algo.ts:823
	// verifyPayTxn(mbr, {
	//             receiver: this.app.address,
	//             amount: globals.assetOptInMinBalance,
	//         })
	// verify receiver
	frame_dig -1 // mbr: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==
	assert

	// verify amount
	frame_dig -1 // mbr: PayTxn
	gtxns Amount
	global AssetOptInMinBalance
	==
	assert

	// src/Immersve.algo.ts:828
	// sendPayment({
	//             receiver: cardFund,
	//             amount: globals.assetOptInMinBalance,
	//         })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// src/Immersve.algo.ts:829
	// receiver: cardFund
	frame_dig -2 // cardFund: Address
	itxn_field Receiver

	// src/Immersve.algo.ts:830
	// amount: globals.assetOptInMinBalance
	global AssetOptInMinBalance
	itxn_field Amount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/Immersve.algo.ts:833
	// this.cardFundAssetOptIn(cardFund, asset)
	frame_dig -3 // asset: AssetID
	frame_dig -2 // cardFund: Address
	callsub cardFundAssetOptIn
	retsub

// cardFundDisableAsset(address,uint64)void
*abi_route_cardFundDisableAsset:
	// asset: uint64
	txna ApplicationArgs 2
	btoi

	// cardFund: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute cardFundDisableAsset(address,uint64)void
	callsub cardFundDisableAsset
	int 1
	return

// cardFundDisableAsset(cardFund: Address, asset: AssetID): void
//
// Allows the depositor (or owner) to CloseOut of an asset, reducing the minimum balance requirement of the account
//
// @param cardFund - The address of the card.
// @param asset - The ID of the asset to be removed.
cardFundDisableAsset:
	proto 2 0

	// src/Immersve.algo.ts:843
	// assert(this.isOwner() || this.isCardFundOwner(cardFund), 'SENDER_NOT_ALLOWED')
	callsub isOwner
	dup
	bnz *skip_or2
	frame_dig -1 // cardFund: Address
	callsub isCardFundOwner
	||

*skip_or2:
	// SENDER_NOT_ALLOWED
	assert

	// src/Immersve.algo.ts:845
	// this.cardFundAssetCloseOut(cardFund, asset)
	frame_dig -2 // asset: AssetID
	frame_dig -1 // cardFund: Address
	callsub cardFundAssetCloseOut
	retsub

// cardFundWithdrawalRequest(address,address,uint64,uint64)byte[32]
*abi_route_cardFundWithdrawalRequest:
	// The ABI return prefix
	byte 0x151f7c75

	// amount: uint64
	txna ApplicationArgs 4
	btoi

	// asset: uint64
	txna ApplicationArgs 3
	btoi

	// recipient: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// cardFund: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute cardFundWithdrawalRequest(address,address,uint64,uint64)byte[32]
	callsub cardFundWithdrawalRequest
	concat
	log
	int 1
	return

// cardFundWithdrawalRequest(cardFund: Address, recipient: Address, asset: AssetID, amount: uint64): bytes32
//
// Allows the Card Holder (or contract owner) to send an amount of assets from the account
// @param cardFund Address to withdraw from
// @param asset Asset to withdraw
// @param amount Amount to withdraw
// @returns Withdrawal hash used for completing or cancelling the withdrawal
cardFundWithdrawalRequest:
	proto 4 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// src/Immersve.algo.ts:858
	// assert(this.isOwner() || this.isCardFundOwner(cardFund), 'SENDER_NOT_ALLOWED')
	callsub isOwner
	dup
	bnz *skip_or3
	frame_dig -1 // cardFund: Address
	callsub isCardFundOwner
	||

*skip_or3:
	// SENDER_NOT_ALLOWED
	assert

	// src/Immersve.algo.ts:860
	// withdrawal: WithdrawalRequest = {
	//             cardFund: cardFund,
	//             recipient: recipient,
	//             asset: asset,
	//             amount: amount,
	//             timestamp: globals.latestTimestamp + this.withdrawal_wait_time.value,
	//             nonce: this.withdrawal_nonce(this.txn.sender).value,
	//         }
	frame_dig -1 // cardFund: Address
	frame_dig -2 // recipient: Address
	concat
	frame_dig -3 // asset: AssetID
	itob
	concat
	frame_dig -4 // amount: uint64
	itob
	concat
	global LatestTimestamp
	byte 0x777774 // "wwt"
	app_global_get
	+
	itob
	concat
	txn Sender
	byte 0x776e // "wn"
	app_local_get
	itob
	concat
	frame_bury 0 // withdrawal: WithdrawalRequest

	// src/Immersve.algo.ts:868
	// this.withdrawal_nonce(this.txn.sender).value = this.withdrawal_nonce(this.txn.sender).value + 1
	txn Sender
	byte 0x776e // "wn"
	txn Sender
	byte 0x776e // "wn"
	app_local_get
	int 1
	+
	app_local_put

	// src/Immersve.algo.ts:869
	// withdrawal_hash = sha256(rawBytes(withdrawal))
	frame_dig 0 // withdrawal: WithdrawalRequest
	sha256
	frame_bury 1 // withdrawal_hash: byte[32]

	// src/Immersve.algo.ts:871
	// this.withdrawals(this.txn.sender, withdrawal_hash).value = withdrawal
	txn Sender
	frame_dig 1 // withdrawal_hash: byte[32]
	frame_dig 0 // withdrawal: WithdrawalRequest
	app_local_put

	// src/Immersve.algo.ts:873
	// this.WithdrawalRequest.log({
	//             cardFund: withdrawal.cardFund,
	//             recipient: withdrawal.recipient,
	//             asset: withdrawal.asset,
	//             amount: withdrawal.amount,
	//             timestamp: withdrawal.timestamp,
	//             nonce: withdrawal.nonce,
	//         })
	byte 0xd85f620a // WithdrawalRequest(address,address,uint64,uint64,uint64,uint64)
	frame_dig 0 // withdrawal: WithdrawalRequest
	extract 0 32
	frame_dig 0 // withdrawal: WithdrawalRequest
	extract 32 32
	concat
	frame_dig 0 // withdrawal: WithdrawalRequest
	extract 64 8
	btoi
	itob
	concat
	frame_dig 0 // withdrawal: WithdrawalRequest
	extract 72 8
	btoi
	itob
	concat
	frame_dig 0 // withdrawal: WithdrawalRequest
	extract 80 8
	btoi
	itob
	concat
	frame_dig 0 // withdrawal: WithdrawalRequest
	extract 88 8
	btoi
	itob
	concat
	concat
	log

	// src/Immersve.algo.ts:882
	// return withdrawal_hash;
	frame_dig 1 // withdrawal_hash: byte[32]

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// cardFundWithdrawalCancel(address,byte[32])void
*abi_route_cardFundWithdrawalCancel:
	// withdrawal_hash: byte[32]
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// cardFund: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute cardFundWithdrawalCancel(address,byte[32])void
	callsub cardFundWithdrawalCancel
	int 1
	return

// cardFundWithdrawalCancel(cardFund: Address, withdrawal_hash: bytes32): void
//
// Allows the Card Holder (or contract owner) to cancel a withdrawal request
// @param cardFund Address to withdraw from
// @param withdrawal_hash Hash of the withdrawal request
cardFundWithdrawalCancel:
	proto 2 0

	// src/Immersve.algo.ts:891
	// assert(this.isOwner() || this.isCardFundOwner(cardFund), 'SENDER_NOT_ALLOWED')
	callsub isOwner
	dup
	bnz *skip_or4
	frame_dig -1 // cardFund: Address
	callsub isCardFundOwner
	||

*skip_or4:
	// SENDER_NOT_ALLOWED
	assert

	// src/Immersve.algo.ts:893
	// this.withdrawals(this.txn.sender, withdrawal_hash).delete()
	txn Sender
	frame_dig -2 // withdrawal_hash: bytes32
	app_local_del
	retsub

// cardFundWithdraw(address,byte[32])void
*abi_route_cardFundWithdraw:
	// withdrawal_hash: byte[32]
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// cardFund: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute cardFundWithdraw(address,byte[32])void
	callsub cardFundWithdraw
	int 1
	return

// cardFundWithdraw(cardFund: Address, withdrawal_hash: bytes32): void
//
// Allows the Card Holder to send an amount of assets from the account
// @param cardFund Address to withdraw from
// @param withdrawal_hash Hash of the withdrawal request
cardFundWithdraw:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// src/Immersve.algo.ts:904
	// assert(this.isOwner() || this.isCardFundOwner(cardFund), 'SENDER_NOT_ALLOWED')
	callsub isOwner
	dup
	bnz *skip_or5
	frame_dig -1 // cardFund: Address
	callsub isCardFundOwner
	||

*skip_or5:
	// SENDER_NOT_ALLOWED
	assert

	// src/Immersve.algo.ts:906
	// withdrawal = this.withdrawals(this.txn.sender, withdrawal_hash).value
	frame_dig -2 // withdrawal_hash: bytes32
	frame_bury 0 // storage key//withdrawal

	// src/Immersve.algo.ts:906
	// withdrawal = this.withdrawals(this.txn.sender, withdrawal_hash).value
	txn Sender
	frame_bury 1 // storage account//withdrawal

	// src/Immersve.algo.ts:908
	// assert(globals.latestTimestamp >= withdrawal.timestamp || this.isOwner(), 'WITHDRAWAL_TIME_INVALID')
	global LatestTimestamp
	frame_dig 1 // storage account//withdrawal
	frame_dig 0 // storage key//withdrawal
	app_local_get
	extract 80 8
	btoi
	>=
	dup
	bnz *skip_or6
	callsub isOwner
	||

*skip_or6:
	// WITHDRAWAL_TIME_INVALID
	assert

	// src/Immersve.algo.ts:911
	// this.withdrawFunds(withdrawal)
	frame_dig 1 // storage account//withdrawal
	frame_dig 0 // storage key//withdrawal
	app_local_get
	callsub withdrawFunds

	// src/Immersve.algo.ts:914
	// this.withdrawals(this.txn.sender, withdrawal_hash).delete()
	txn Sender
	frame_dig -2 // withdrawal_hash: bytes32
	app_local_del
	retsub

// cardFundWithdrawEarly(address,byte[32],byte[64])void
*abi_route_cardFundWithdrawEarly:
	// early_withdrawal_sig: byte[64]
	txna ApplicationArgs 3
	dup
	len
	int 64
	==
	assert

	// withdrawal_hash: byte[32]
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// cardFund: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute cardFundWithdrawEarly(address,byte[32],byte[64])void
	callsub cardFundWithdrawEarly
	int 1
	return

// cardFundWithdrawEarly(cardFund: Address, withdrawal_hash: bytes32, early_withdrawal_sig: bytes64): void
//
// Withdraws funds before the withdrawal timestamp has lapsed, by using the early withdrawal signature provided by Immersve.
// @param cardFund - The address of the card.
// @param withdrawal_hash - The hash of the withdrawal.
// @param early_withdrawal_sig - The signature for early withdrawal.
cardFundWithdrawEarly:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// src/Immersve.algo.ts:924
	// assert(this.isCardFundOwner(cardFund), 'SENDER_NOT_ALLOWED')
	frame_dig -1 // cardFund: Address
	callsub isCardFundOwner

	// SENDER_NOT_ALLOWED
	assert

	// src/Immersve.algo.ts:926
	// withdrawal = this.withdrawals(this.txn.sender, withdrawal_hash).value
	frame_dig -2 // withdrawal_hash: bytes32
	frame_bury 0 // storage key//withdrawal

	// src/Immersve.algo.ts:926
	// withdrawal = this.withdrawals(this.txn.sender, withdrawal_hash).value
	txn Sender
	frame_bury 1 // storage account//withdrawal

	// *if1_condition
	// src/Immersve.algo.ts:929
	// globals.latestTimestamp < withdrawal.timestamp
	global LatestTimestamp
	frame_dig 1 // storage account//withdrawal
	frame_dig 0 // storage key//withdrawal
	app_local_get
	extract 80 8
	btoi
	<
	bz *if1_end

// *if1_consequent
*while_0:

*while_0_continue:
	// src/Immersve.algo.ts:932
	// globals.opcodeBudget < 2500
	global OpcodeBudget
	int 2500
	<
	bz *while_0_end

	// src/Immersve.algo.ts:933
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit
	b *while_0

*while_0_end:
	// src/Immersve.algo.ts:936
	// assert(
	//                 ed25519VerifyBare(withdrawal_hash, early_withdrawal_sig, this.early_withdrawal_pubkey.value),
	//                 'SIGNATURE_INVALID'
	//             )
	frame_dig -2 // withdrawal_hash: bytes32
	frame_dig -3 // early_withdrawal_sig: bytes64
	byte 0x6577706b // "ewpk"
	app_global_get
	ed25519verify_bare

	// SIGNATURE_INVALID
	assert

*if1_end:
	// src/Immersve.algo.ts:943
	// this.withdrawFunds(withdrawal)
	frame_dig 1 // storage account//withdrawal
	frame_dig 0 // storage key//withdrawal
	app_local_get
	callsub withdrawFunds

	// src/Immersve.algo.ts:946
	// this.withdrawals(this.txn.sender, withdrawal_hash).delete()
	txn Sender
	frame_dig -2 // withdrawal_hash: bytes32
	app_local_del
	retsub

*create_NoOp:
	method "deploy(address)address"
	txna ApplicationArgs 0
	match *abi_route_deploy
	err

*call_NoOp:
	method "owner()address"
	method "transferOwnership(address)void"
	method "pauser()address"
	method "pause()void"
	method "unpause()void"
	method "updatePauser(address)void"
	method "setWithdrawalTimeout(uint64)void"
	method "setEarlyWithdrawalPubkey(byte[32])void"
	method "partnerChannelCreate(pay,string)address"
	method "partnerChannelClose(address)void"
	method "cardFundCreate(pay,address,uint64)address"
	method "cardFundClose(address)void"
	method "cardFundRecover(address,address)void"
	method "assetAllowlistAdd(pay,uint64,address)void"
	method "assetAllowlistRemove(uint64)void"
	method "cardFundDebit(address,uint64,uint64,uint64)void"
	method "getRefundAddress()address"
	method "setRefundAddress(address)void"
	method "cardFundRefund(address,uint64,uint64,uint64)void"
	method "getNextSettlementNonce()uint64"
	method "getNextCardFundNonce(address)uint64"
	method "getCardFundData(address)(address,address,address,uint64)"
	method "getSettlementAddress(uint64)address"
	method "setSettlementAddress(uint64,address)void"
	method "settle(uint64,uint64,uint64)void"
	method "cardFundEnableAsset(pay,address,uint64)void"
	method "cardFundDisableAsset(address,uint64)void"
	method "cardFundWithdrawalRequest(address,address,uint64,uint64)byte[32]"
	method "cardFundWithdrawalCancel(address,byte[32])void"
	method "cardFundWithdraw(address,byte[32])void"
	method "cardFundWithdrawEarly(address,byte[32],byte[64])void"
	txna ApplicationArgs 0
	match *abi_route_owner *abi_route_transferOwnership *abi_route_pauser *abi_route_pause *abi_route_unpause *abi_route_updatePauser *abi_route_setWithdrawalTimeout *abi_route_setEarlyWithdrawalPubkey *abi_route_partnerChannelCreate *abi_route_partnerChannelClose *abi_route_cardFundCreate *abi_route_cardFundClose *abi_route_cardFundRecover *abi_route_assetAllowlistAdd *abi_route_assetAllowlistRemove *abi_route_cardFundDebit *abi_route_getRefundAddress *abi_route_setRefundAddress *abi_route_cardFundRefund *abi_route_getNextSettlementNonce *abi_route_getNextCardFundNonce *abi_route_getCardFundData *abi_route_getSettlementAddress *abi_route_setSettlementAddress *abi_route_settle *abi_route_cardFundEnableAsset *abi_route_cardFundDisableAsset *abi_route_cardFundWithdrawalRequest *abi_route_cardFundWithdrawalCancel *abi_route_cardFundWithdraw *abi_route_cardFundWithdrawEarly
	err

*call_OptIn:
	method "cardFundWithdrawalRequest(address,address,uint64,uint64)byte[32]"
	txna ApplicationArgs 0
	match *abi_route_cardFundWithdrawalRequest
	err

*call_CloseOut:
	method "cardFundWithdraw(address,byte[32])void"
	txna ApplicationArgs 0
	match *abi_route_cardFundWithdraw
	err

*call_UpdateApplication:
	method "update()void"
	txna ApplicationArgs 0
	match *abi_route_update
	err

*call_DeleteApplication:
	method "destroy()void"
	txna ApplicationArgs 0
	match *abi_route_destroy
	err

*process_static_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -1 // element
	concat
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub

*process_dynamic_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -2 // head offset
	concat
	frame_bury -4 // tuple head
	frame_dig -1 // element
	dup
	len
	frame_dig -2 // head offset
	btoi
	+
	itob
	extract 6 2
	frame_bury -2 // head offset
	frame_dig -3 // tuple tail
	swap
	concat
	frame_bury -3 // tuple tail
	frame_dig -4 // tuple head
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub