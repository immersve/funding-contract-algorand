#pragma version 10

// This TEAL was generated by TEALScript v0.86.0
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
int 6
*
txn OnCompletion
+
switch *call_NoOp *call_OptIn *call_CloseOut *NOT_IMPLEMENTED *call_UpdateApplication *call_DeleteApplication *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	err

// onlyOwner(): void
//
// Assert the transaction sender is the owner of the contract.
onlyOwner:
	proto 0 0

	// src/roles/Ownable.algo.ts:52
	// assert(this.txn.sender === this._owner.value)
	txn Sender
	byte 0x5f6f776e6572 // "_owner"
	app_global_get
	==
	assert
	retsub

// isOwner(): boolean
//
// Checks if the current transaction sender is the owner.
// @returns {boolean} True if the sender is the owner, false otherwise.
isOwner:
	proto 0 1

	// src/roles/Ownable.algo.ts:60
	// return this.txn.sender === this._owner.value;
	txn Sender
	byte 0x5f6f776e6572 // "_owner"
	app_global_get
	==
	retsub

// owner()address
*abi_route_owner:
	// The ABI return prefix
	byte 0x151f7c75

	// execute owner()address
	callsub owner
	concat
	log
	int 1
	return

// owner(): Address
owner:
	proto 0 1

	// src/roles/Ownable.algo.ts:66
	// return this._owner.value;
	byte 0x5f6f776e6572 // "_owner"
	app_global_get
	retsub

// _transferOwnership(newOwner: Address): void
//
// Transfers the ownership of the contract to a new owner.
// @param newOwner The address of the new owner.
_transferOwnership:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/roles/Ownable.algo.ts:75
	// previousOwner = this._owner.exists ? this._owner.value : globals.zeroAddress
	txna Applications 0
	byte 0x5f6f776e6572 // "_owner"
	app_global_get_ex
	swap
	pop
	bz *ternary1_false
	byte 0x5f6f776e6572 // "_owner"
	app_global_get
	b *ternary1_end

*ternary1_false:
	global ZeroAddress

*ternary1_end:
	frame_bury 0 // previousOwner: address

	// src/roles/Ownable.algo.ts:76
	// this._owner.value = newOwner
	byte 0x5f6f776e6572 // "_owner"
	frame_dig -1 // newOwner: Address
	app_global_put

	// src/roles/Ownable.algo.ts:78
	// this.OwnershipTransferred.log({
	//       previousOwner: previousOwner,
	//       newOwner: newOwner,
	//     })
	byte 0x9a223efb // OwnershipTransferred(address,address)
	frame_dig 0 // previousOwner: address
	frame_dig -1 // newOwner: Address
	concat
	concat
	log
	retsub

// transferOwnership(address)void
*abi_route_transferOwnership:
	// newOwner: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute transferOwnership(address)void
	callsub transferOwnership
	int 1
	return

// transferOwnership(newOwner: Address): void
//
// Transfers the ownership of the contract to a new owner.
// Requires the caller to be the current owner.
//
// @param newOwner The address of the new owner.
transferOwnership:
	proto 1 0

	// src/roles/Ownable.algo.ts:92
	// assert(this.isOwner())
	callsub isOwner
	assert

	// src/roles/Ownable.algo.ts:94
	// this._transferOwnership(newOwner)
	frame_dig -1 // newOwner: Address
	callsub _transferOwnership
	retsub

// isCardHolder(partner: string, card: Address): boolean
//
// Check if the current transaction sender is the Card Holder of the card account
// @param card Address to check
// @returns True if the sender is the Card Holder of the card
isCardHolder:
	proto 2 1

	// src/Immersve.algo.ts:126
	// return this.cards({ partner: partner, cardHolder: this.txn.sender } as CardDetails).value === card;
	byte 0x63 // "c"
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x0022 // initial head offset
	frame_dig -1 // partner: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	txn Sender
	callsub *process_static_tuple_element
	pop // pop head offset
	concat // concat head and tail
	concat
	box_get
	assert
	frame_dig -2 // card: Address
	==
	retsub

// deploy(address)address
*abi_route_deploy:
	// The ABI return prefix
	byte 0x151f7c75

	// owner: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute deploy(address)address
	callsub deploy
	concat
	log
	int 1
	return

// deploy(owner: Address): Address
//
// Deploy a Partner, setting the owner as provided
deploy:
	proto 1 1

	// src/Immersve.algo.ts:135
	// this._transferOwnership(owner)
	frame_dig -1 // owner: Address
	callsub _transferOwnership

	// src/Immersve.algo.ts:137
	// return this.app.address;
	global CurrentApplicationAddress
	retsub

// update()void
*abi_route_update:
	// execute update()void
	callsub update
	int 1
	return

// update(): void
//
// Allows the owner to update the smart contract
update:
	proto 0 0

	// src/Immersve.algo.ts:145
	// this.onlyOwner()
	callsub onlyOwner
	retsub

// destroy()void
*abi_route_destroy:
	// execute destroy()void
	callsub destroy
	int 1
	return

// destroy(): void
//
// Destroy the smart contract, sending all Algo to the owner account. This can only be done if there are no active cards
destroy:
	proto 0 0

	// src/Immersve.algo.ts:153
	// this.onlyOwner()
	callsub onlyOwner

	// src/Immersve.algo.ts:156
	// assert(!this.active_cards.value)
	byte 0x63 // "c"
	app_global_get
	!
	assert

	// src/Immersve.algo.ts:158
	// assert(!this.active_partners.value)
	byte 0x70 // "p"
	app_global_get
	!
	assert

	// src/Immersve.algo.ts:160
	// sendPayment({
	//             receiver: this.app.address,
	//             amount: 0,
	//             closeRemainderTo: this.owner(),
	//         })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// src/Immersve.algo.ts:161
	// receiver: this.app.address
	global CurrentApplicationAddress
	itxn_field Receiver

	// src/Immersve.algo.ts:162
	// amount: 0
	int 0
	itxn_field Amount

	// src/Immersve.algo.ts:163
	// closeRemainderTo: this.owner()
	callsub owner
	itxn_field CloseRemainderTo

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// setWithdrawalRounds(uint64)void
*abi_route_setWithdrawalRounds:
	// rounds: uint64
	txna ApplicationArgs 1
	btoi

	// execute setWithdrawalRounds(uint64)void
	callsub setWithdrawalRounds
	int 1
	return

// setWithdrawalRounds(rounds: uint64): void
//
// Set the number of rounds a withdrawal request must wait until being withdrawn
// @param rounds New number of rounds to wait
setWithdrawalRounds:
	proto 1 0

	// src/Immersve.algo.ts:173
	// this.onlyOwner()
	callsub onlyOwner

	// src/Immersve.algo.ts:175
	// this.withdrawal_wait_time.value = rounds
	byte 0x77 // "w"
	frame_dig -1 // rounds: uint64
	app_global_put
	retsub

// partnerCreate(pay,string)address
*abi_route_partnerCreate:
	// The ABI return prefix
	byte 0x151f7c75

	// partner: string
	txna ApplicationArgs 1
	extract 2 0

	// mbr: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==
	assert

	// execute partnerCreate(pay,string)address
	callsub partnerCreate
	concat
	log
	int 1
	return

// partnerCreate(mbr: PayTxn, partner: string): Address
//
// Creates a partner account and associates it with the provided partner name.
// Only the owner of the contract can call this function.
//
// @param mbr - The PayTxn object representing the payment transaction.
// @param partner - The name of the partner.
// @returns The address of the newly created partner account.
partnerCreate:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// src/Immersve.algo.ts:187
	// this.onlyOwner()
	callsub onlyOwner

	// src/Immersve.algo.ts:189
	// assert(!this.partners(partner).exists)
	byte 0x70 // "p"
	frame_dig -2 // partner: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	box_len
	swap
	pop
	!
	assert

	// src/Immersve.algo.ts:191
	// boxCost = 2500 + 400 * (3 + len(partner) + 32)
	int 2500
	int 400
	int 3
	frame_dig -2 // partner: string
	len
	+
	int 32
	+
	*
	+
	frame_bury 0 // boxCost: uint64

	// src/Immersve.algo.ts:193
	// verifyPayTxn(mbr, {
	//             receiver: this.app.address,
	//             amount: globals.minBalance + globals.assetOptInMinBalance + boxCost,
	//         })
	// verify receiver
	frame_dig -1 // mbr: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==
	assert

	// verify amount
	frame_dig -1 // mbr: PayTxn
	gtxns Amount
	global MinBalance
	global AssetOptInMinBalance
	+
	frame_dig 0 // boxCost: uint64
	+
	==
	assert

	// src/Immersve.algo.ts:199
	// partnerAddr = sendMethodCall<typeof ControlledAddress.prototype.new>({
	//             onCompletion: OnCompletion.DeleteApplication,
	//             approvalProgram: ControlledAddress.approvalProgram(),
	//             clearStateProgram: ControlledAddress.clearProgram(),
	//         })
	itxn_begin
	int appl
	itxn_field TypeEnum
	method "new()address"
	itxn_field ApplicationArgs

	// src/Immersve.algo.ts:200
	// onCompletion: OnCompletion.DeleteApplication
	int 5 // DeleteApplication
	itxn_field OnCompletion

	// src/Immersve.algo.ts:201
	// approvalProgram: ControlledAddress.approvalProgram()
	byte b64 CiACAQAxGBSBBgsxGQiNDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJwCABBUffHWIAARQsCJDigABsSKyEDIKsgcjsggyDrIgI7IBszIKiYAEVh0v6jYaAI4B/80A
	itxn_field ApprovalProgram

	// src/Immersve.algo.ts:202
	// clearStateProgram: ControlledAddress.clearProgram()
	byte b64 Cg==
	itxn_field ClearStateProgram

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	int 1
	-
	itxnas Logs
	extract 4 0
	frame_bury 1 // partnerAddr: address

	// src/Immersve.algo.ts:206
	// sendPayment({
	//             receiver: partnerAddr,
	//             amount: globals.minBalance,
	//         })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// src/Immersve.algo.ts:207
	// receiver: partnerAddr
	frame_dig 1 // partnerAddr: address
	itxn_field Receiver

	// src/Immersve.algo.ts:208
	// amount: globals.minBalance
	global MinBalance
	itxn_field Amount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/Immersve.algo.ts:211
	// this.partners(partner).value = partnerAddr
	byte 0x70 // "p"
	frame_dig -2 // partner: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	frame_dig 1 // partnerAddr: address
	box_put

	// src/Immersve.algo.ts:214
	// this.active_partners.value = this.active_partners.value + 1
	byte 0x70 // "p"
	dup
	app_global_get
	int 1
	+
	app_global_put

	// src/Immersve.algo.ts:216
	// return partnerAddr;
	frame_dig 1 // partnerAddr: address

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// partnerClose(string)void
*abi_route_partnerClose:
	// partner: string
	txna ApplicationArgs 1
	extract 2 0

	// execute partnerClose(string)void
	callsub partnerClose
	int 1
	return

// partnerClose(partner: string): void
partnerClose:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/Immersve.algo.ts:220
	// this.onlyOwner()
	callsub onlyOwner

	// src/Immersve.algo.ts:222
	// sendPayment({
	//             sender: this.partners(partner).value,
	//             receiver: this.partners(partner).value,
	//             amount: 0,
	//             closeRemainderTo: this.txn.sender,
	//         })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// src/Immersve.algo.ts:223
	// sender: this.partners(partner).value
	byte 0x70 // "p"
	frame_dig -1 // partner: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	box_get
	assert
	itxn_field Sender

	// src/Immersve.algo.ts:224
	// receiver: this.partners(partner).value
	byte 0x70 // "p"
	frame_dig -1 // partner: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	box_get
	assert
	itxn_field Receiver

	// src/Immersve.algo.ts:225
	// amount: 0
	int 0
	itxn_field Amount

	// src/Immersve.algo.ts:226
	// closeRemainderTo: this.txn.sender
	txn Sender
	itxn_field CloseRemainderTo

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/Immersve.algo.ts:229
	// boxCost = 2500 + 400 * (3 + len(partner) + 32)
	int 2500
	int 400
	int 3
	frame_dig -1 // partner: string
	len
	+
	int 32
	+
	*
	+
	frame_bury 0 // boxCost: uint64

	// src/Immersve.algo.ts:231
	// sendPayment({
	//             receiver: this.txn.sender,
	//             amount: boxCost,
	//         })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// src/Immersve.algo.ts:232
	// receiver: this.txn.sender
	txn Sender
	itxn_field Receiver

	// src/Immersve.algo.ts:233
	// amount: boxCost
	frame_dig 0 // boxCost: uint64
	itxn_field Amount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/Immersve.algo.ts:237
	// this.partners(partner).delete()
	byte 0x70 // "p"
	frame_dig -1 // partner: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	box_del

	// src/Immersve.algo.ts:240
	// this.active_partners.value = this.active_partners.value - 1
	byte 0x70 // "p"
	dup
	app_global_get
	int 1
	-
	app_global_put
	retsub

// cardCreate(pay,string,address)address
*abi_route_cardCreate:
	// The ABI return prefix
	byte 0x151f7c75

	// cardHolder: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// partner: string
	txna ApplicationArgs 1
	extract 2 0

	// mbr: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==
	assert

	// execute cardCreate(pay,string,address)address
	callsub cardCreate
	concat
	log
	int 1
	return

// cardCreate(mbr: PayTxn, partner: string, cardHolder: Address): Address
//
// Create account. This generates a brand new account and funds the minimum balance requirement
// @param cardHolder Address to have control over asset withdrawals
// @returns Newly generated account used by their card
cardCreate:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 2

	// src/Immersve.algo.ts:249
	// this.onlyOwner()
	callsub onlyOwner

	// src/Immersve.algo.ts:251
	// assert(this.partners(partner).exists)
	byte 0x70 // "p"
	frame_dig -2 // partner: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	box_len
	swap
	pop
	assert

	// src/Immersve.algo.ts:253
	// cardFunds: CardDetails = { partner: partner, cardHolder: cardHolder }
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x0022 // initial head offset
	frame_dig -2 // partner: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	frame_dig -3 // cardHolder: Address
	callsub *process_static_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury 0 // cardFunds: CardDetails

	// src/Immersve.algo.ts:254
	// boxCost = 2500 + 400 * (1 + len(cardFunds) + 32)
	int 2500
	int 400
	int 1
	frame_dig 0 // cardFunds: CardDetails
	len
	+
	int 32
	+
	*
	+
	frame_bury 1 // boxCost: uint64

	// src/Immersve.algo.ts:256
	// verifyPayTxn(mbr, {
	//             receiver: this.app.address,
	//             amount: globals.minBalance + boxCost,
	//         })
	// verify receiver
	frame_dig -1 // mbr: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==
	assert

	// verify amount
	frame_dig -1 // mbr: PayTxn
	gtxns Amount
	global MinBalance
	frame_dig 1 // boxCost: uint64
	+
	==
	assert

	// src/Immersve.algo.ts:262
	// cardAddr = sendMethodCall<typeof ControlledAddress.prototype.new>({
	//             onCompletion: OnCompletion.DeleteApplication,
	//             approvalProgram: ControlledAddress.approvalProgram(),
	//             clearStateProgram: ControlledAddress.clearProgram(),
	//         })
	itxn_begin
	int appl
	itxn_field TypeEnum
	method "new()address"
	itxn_field ApplicationArgs

	// src/Immersve.algo.ts:263
	// onCompletion: OnCompletion.DeleteApplication
	int 5 // DeleteApplication
	itxn_field OnCompletion

	// src/Immersve.algo.ts:264
	// approvalProgram: ControlledAddress.approvalProgram()
	byte b64 CiACAQAxGBSBBgsxGQiNDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJwCABBUffHWIAARQsCJDigABsSKyEDIKsgcjsggyDrIgI7IBszIKiYAEVh0v6jYaAI4B/80A
	itxn_field ApprovalProgram

	// src/Immersve.algo.ts:265
	// clearStateProgram: ControlledAddress.clearProgram()
	byte b64 Cg==
	itxn_field ClearStateProgram

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	int 1
	-
	itxnas Logs
	extract 4 0
	frame_bury 2 // cardAddr: address

	// src/Immersve.algo.ts:269
	// sendPayment({
	//             receiver: cardAddr,
	//             amount: globals.minBalance,
	//         })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// src/Immersve.algo.ts:270
	// receiver: cardAddr
	frame_dig 2 // cardAddr: address
	itxn_field Receiver

	// src/Immersve.algo.ts:271
	// amount: globals.minBalance
	global MinBalance
	itxn_field Amount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/Immersve.algo.ts:275
	// this.cards(cardFunds).value = cardAddr
	byte 0x63 // "c"
	frame_dig 0 // cardFunds: CardDetails
	concat
	frame_dig 2 // cardAddr: address
	box_put

	// src/Immersve.algo.ts:278
	// this.active_cards.value = this.active_cards.value + 1
	byte 0x63 // "c"
	dup
	app_global_get
	int 1
	+
	app_global_put

	// src/Immersve.algo.ts:281
	// return cardAddr;
	frame_dig 2 // cardAddr: address

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// cardClose(string,address,address)void
*abi_route_cardClose:
	// card: address
	txna ApplicationArgs 3
	dup
	len
	int 32
	==
	assert

	// cardHolder: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// partner: string
	txna ApplicationArgs 1
	extract 2 0

	// execute cardClose(string,address,address)void
	callsub cardClose
	int 1
	return

// cardClose(partner: string, cardHolder: Address, card: Address): void
//
// Close account. This permanently removes the rekey and deletes the account from the ledger
// @param partner Funding Channel name
// @param cardHolder Address which has control over asset withdrawals
// @param card Address to close
cardClose:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// src/Immersve.algo.ts:291
	// this.onlyOwner()
	callsub onlyOwner

	// src/Immersve.algo.ts:293
	// sendPayment({
	//             sender: card,
	//             receiver: card,
	//             amount: 0,
	//             closeRemainderTo: this.txn.sender,
	//         })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// src/Immersve.algo.ts:294
	// sender: card
	frame_dig -3 // card: Address
	itxn_field Sender

	// src/Immersve.algo.ts:295
	// receiver: card
	frame_dig -3 // card: Address
	itxn_field Receiver

	// src/Immersve.algo.ts:296
	// amount: 0
	int 0
	itxn_field Amount

	// src/Immersve.algo.ts:297
	// closeRemainderTo: this.txn.sender
	txn Sender
	itxn_field CloseRemainderTo

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/Immersve.algo.ts:300
	// cardFunds: CardDetails = { partner: partner, cardHolder: cardHolder }
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x0022 // initial head offset
	frame_dig -1 // partner: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	frame_dig -2 // cardHolder: Address
	callsub *process_static_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury 0 // cardFunds: CardDetails

	// src/Immersve.algo.ts:301
	// boxCost = 2500 + 400 * (1 + len(cardFunds) + 32)
	int 2500
	int 400
	int 1
	frame_dig 0 // cardFunds: CardDetails
	len
	+
	int 32
	+
	*
	+
	frame_bury 1 // boxCost: uint64

	// src/Immersve.algo.ts:303
	// sendPayment({
	//             receiver: this.txn.sender,
	//             amount: boxCost,
	//         })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// src/Immersve.algo.ts:304
	// receiver: this.txn.sender
	txn Sender
	itxn_field Receiver

	// src/Immersve.algo.ts:305
	// amount: boxCost
	frame_dig 1 // boxCost: uint64
	itxn_field Amount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/Immersve.algo.ts:309
	// this.cards(cardFunds).delete()
	byte 0x63 // "c"
	frame_dig 0 // cardFunds: CardDetails
	concat
	box_del

	// src/Immersve.algo.ts:312
	// this.active_cards.value = this.active_cards.value - 1
	byte 0x63 // "c"
	dup
	app_global_get
	int 1
	-
	app_global_put
	retsub

// cardRecover(string,address,address)void
*abi_route_cardRecover:
	// newCardHolder: address
	txna ApplicationArgs 3
	dup
	len
	int 32
	==
	assert

	// oldCardHolder: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// partner: string
	txna ApplicationArgs 1
	extract 2 0

	// execute cardRecover(string,address,address)void
	callsub cardRecover
	int 1
	return

// cardRecover(partner: string, oldCardHolder: Address, newCardHolder: Address): void
//
// Recovers funds from an old card and transfers them to a new card.
// Only the owner of the contract can perform this operation.
//
// @param partner - The partner associated with the cards.
// @param oldCardHolder - The address of the old card holder.
// @param newCardHolder - The address of the new card holder.
cardRecover:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// src/Immersve.algo.ts:324
	// this.onlyOwner()
	callsub onlyOwner

	// src/Immersve.algo.ts:326
	// oldCardFunds: CardDetails = { partner: partner, cardHolder: oldCardHolder }
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x0022 // initial head offset
	frame_dig -1 // partner: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	frame_dig -2 // oldCardHolder: Address
	callsub *process_static_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury 0 // oldCardFunds: CardDetails

	// src/Immersve.algo.ts:327
	// newCardFunds: CardDetails = { partner: partner, cardHolder: newCardHolder }
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x0022 // initial head offset
	frame_dig -1 // partner: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	frame_dig -3 // newCardHolder: Address
	callsub *process_static_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury 1 // newCardFunds: CardDetails

	// src/Immersve.algo.ts:328
	// this.cards(newCardFunds).value = this.cards(oldCardFunds).value
	byte 0x63 // "c"
	frame_dig 1 // newCardFunds: CardDetails
	concat
	byte 0x63 // "c"
	frame_dig 0 // oldCardFunds: CardDetails
	concat
	box_get
	assert
	box_put

	// src/Immersve.algo.ts:330
	// this.cards(oldCardFunds).delete()
	byte 0x63 // "c"
	frame_dig 0 // oldCardFunds: CardDetails
	concat
	box_del
	retsub

// assetAllowlistAdd(pay,uint64)void
*abi_route_assetAllowlistAdd:
	// asset: uint64
	txna ApplicationArgs 1
	btoi

	// mbr: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==
	assert

	// execute assetAllowlistAdd(pay,uint64)void
	callsub assetAllowlistAdd
	int 1
	return

// assetAllowlistAdd(mbr: PayTxn, asset: AssetID): void
//
// Allows the master contract to flag intent of accepting an asset.
// This can be considered the whitelists whitelist.
//
// @param mbr - Payment transaction of minimum balance requirement
// @param asset - The AssetID of the asset being transferred.
assetAllowlistAdd:
	proto 2 0

	// src/Immersve.algo.ts:341
	// this.onlyOwner()
	callsub onlyOwner

	// src/Immersve.algo.ts:343
	// verifyPayTxn(mbr, {
	//             receiver: this.app.address,
	//             amount: globals.assetOptInMinBalance,
	//         })
	// verify receiver
	frame_dig -1 // mbr: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==
	assert

	// verify amount
	frame_dig -1 // mbr: PayTxn
	gtxns Amount
	global AssetOptInMinBalance
	==
	assert

	// src/Immersve.algo.ts:348
	// sendAssetTransfer({
	//             sender: this.app.address,
	//             assetReceiver: this.app.address,
	//             xferAsset: asset,
	//             assetAmount: 0,
	//         })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// src/Immersve.algo.ts:349
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// src/Immersve.algo.ts:350
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// src/Immersve.algo.ts:351
	// xferAsset: asset
	frame_dig -2 // asset: AssetID
	itxn_field XferAsset

	// src/Immersve.algo.ts:352
	// assetAmount: 0
	int 0
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// assetAllowlistRemove(uint64)void
*abi_route_assetAllowlistRemove:
	// asset: uint64
	txna ApplicationArgs 1
	btoi

	// execute assetAllowlistRemove(uint64)void
	callsub assetAllowlistRemove
	int 1
	return

// assetAllowlistRemove(asset: AssetID): void
//
// Allows the master contract to reject accepting an asset.
//
// @param asset - The AssetID of the asset being transferred.
assetAllowlistRemove:
	proto 1 0

	// src/Immersve.algo.ts:362
	// this.onlyOwner()
	callsub onlyOwner

	// src/Immersve.algo.ts:365
	// sendAssetTransfer({
	//             sender: this.app.address,
	//             assetReceiver: this.app.address,
	//             assetCloseTo: this.app.address,
	//             xferAsset: asset,
	//             assetAmount: 0,
	//         })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// src/Immersve.algo.ts:366
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// src/Immersve.algo.ts:367
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// src/Immersve.algo.ts:368
	// assetCloseTo: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetCloseTo

	// src/Immersve.algo.ts:369
	// xferAsset: asset
	frame_dig -1 // asset: AssetID
	itxn_field XferAsset

	// src/Immersve.algo.ts:370
	// assetAmount: 0
	int 0
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/Immersve.algo.ts:373
	// sendPayment({
	//             receiver: this.txn.sender,
	//             amount: globals.assetOptInMinBalance,
	//         })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// src/Immersve.algo.ts:374
	// receiver: this.txn.sender
	txn Sender
	itxn_field Receiver

	// src/Immersve.algo.ts:375
	// amount: globals.assetOptInMinBalance
	global AssetOptInMinBalance
	itxn_field Amount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// partnerAcceptAsset(pay,string,uint64)void
*abi_route_partnerAcceptAsset:
	// asset: uint64
	txna ApplicationArgs 2
	btoi

	// partner: string
	txna ApplicationArgs 1
	extract 2 0

	// mbr: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==
	assert

	// execute partnerAcceptAsset(pay,string,uint64)void
	callsub partnerAcceptAsset
	int 1
	return

// partnerAcceptAsset(mbr: PayTxn, partner: string, asset: AssetID): void
//
// Allows the specified asset to be transferred for users of this partner.
//
// @param mbr - The PayTxn object representing the transaction.
// @param asset - The ID of the asset to be allowed.
partnerAcceptAsset:
	proto 3 0

	// src/Immersve.algo.ts:386
	// this.onlyOwner()
	callsub onlyOwner

	// src/Immersve.algo.ts:388
	// verifyPayTxn(mbr, {
	//             receiver: this.app.address,
	//             amount: globals.assetOptInMinBalance,
	//         })
	// verify receiver
	frame_dig -1 // mbr: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==
	assert

	// verify amount
	frame_dig -1 // mbr: PayTxn
	gtxns Amount
	global AssetOptInMinBalance
	==
	assert

	// src/Immersve.algo.ts:393
	// sendPayment({
	//             sender: this.app.address,
	//             receiver: this.partners(partner).value,
	//             amount: globals.assetOptInMinBalance,
	//         })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// src/Immersve.algo.ts:394
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// src/Immersve.algo.ts:395
	// receiver: this.partners(partner).value
	byte 0x70 // "p"
	frame_dig -2 // partner: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	box_get
	assert
	itxn_field Receiver

	// src/Immersve.algo.ts:396
	// amount: globals.assetOptInMinBalance
	global AssetOptInMinBalance
	itxn_field Amount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/Immersve.algo.ts:399
	// sendAssetTransfer({
	//             sender: this.partners(partner).value,
	//             assetReceiver: this.partners(partner).value,
	//             xferAsset: asset,
	//             assetAmount: 0,
	//         })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// src/Immersve.algo.ts:400
	// sender: this.partners(partner).value
	byte 0x70 // "p"
	frame_dig -2 // partner: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	box_get
	assert
	itxn_field Sender

	// src/Immersve.algo.ts:401
	// assetReceiver: this.partners(partner).value
	byte 0x70 // "p"
	frame_dig -2 // partner: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	box_get
	assert
	itxn_field AssetReceiver

	// src/Immersve.algo.ts:402
	// xferAsset: asset
	frame_dig -3 // asset: AssetID
	itxn_field XferAsset

	// src/Immersve.algo.ts:403
	// assetAmount: 0
	int 0
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// partnerRejectAsset(string,uint64)void
*abi_route_partnerRejectAsset:
	// asset: uint64
	txna ApplicationArgs 2
	btoi

	// partner: string
	txna ApplicationArgs 1
	extract 2 0

	// execute partnerRejectAsset(string,uint64)void
	callsub partnerRejectAsset
	int 1
	return

// partnerRejectAsset(partner: string, asset: AssetID): void
//
// Revokes an asset by closing out its balance and transferring the minimum balance to the sender.
//
// @param asset The ID of the asset to revoke.
partnerRejectAsset:
	proto 2 0

	// src/Immersve.algo.ts:413
	// this.onlyOwner()
	callsub onlyOwner

	// src/Immersve.algo.ts:416
	// sendAssetTransfer({
	//             sender: this.partners(partner).value,
	//             assetReceiver: this.partners(partner).value,
	//             assetCloseTo: this.partners(partner).value,
	//             xferAsset: asset,
	//             assetAmount: 0,
	//         })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// src/Immersve.algo.ts:417
	// sender: this.partners(partner).value
	byte 0x70 // "p"
	frame_dig -1 // partner: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	box_get
	assert
	itxn_field Sender

	// src/Immersve.algo.ts:418
	// assetReceiver: this.partners(partner).value
	byte 0x70 // "p"
	frame_dig -1 // partner: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	box_get
	assert
	itxn_field AssetReceiver

	// src/Immersve.algo.ts:419
	// assetCloseTo: this.partners(partner).value
	byte 0x70 // "p"
	frame_dig -1 // partner: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	box_get
	assert
	itxn_field AssetCloseTo

	// src/Immersve.algo.ts:420
	// xferAsset: asset
	frame_dig -2 // asset: AssetID
	itxn_field XferAsset

	// src/Immersve.algo.ts:421
	// assetAmount: 0
	int 0
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/Immersve.algo.ts:424
	// sendPayment({
	//             sender: this.partners(partner).value,
	//             receiver: this.txn.sender,
	//             amount: globals.assetOptInMinBalance,
	//         })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// src/Immersve.algo.ts:425
	// sender: this.partners(partner).value
	byte 0x70 // "p"
	frame_dig -1 // partner: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	box_get
	assert
	itxn_field Sender

	// src/Immersve.algo.ts:426
	// receiver: this.txn.sender
	txn Sender
	itxn_field Receiver

	// src/Immersve.algo.ts:427
	// amount: globals.assetOptInMinBalance
	global AssetOptInMinBalance
	itxn_field Amount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// cardDebit(string,address,uint64,uint64)void
*abi_route_cardDebit:
	// amount: uint64
	txna ApplicationArgs 4
	btoi

	// asset: uint64
	txna ApplicationArgs 3
	btoi

	// card: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// partner: string
	txna ApplicationArgs 1
	extract 2 0

	// execute cardDebit(string,address,uint64,uint64)void
	callsub cardDebit
	int 1
	return

// cardDebit(partner: string, card: Address, asset: AssetID, amount: uint64): void
//
// Debits the specified amount of the given asset from the card account.
// Only the owner of the contract can perform this operation.
//
// @param card The card account from which the asset will be debited.
// @param amount The amount of the asset to be debited.
cardDebit:
	proto 4 0

	// src/Immersve.algo.ts:439
	// this.onlyOwner()
	callsub onlyOwner

	// src/Immersve.algo.ts:441
	// sendAssetTransfer({
	//             sender: card,
	//             assetReceiver: this.app.address,
	//             xferAsset: asset,
	//             assetAmount: amount,
	//         })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// src/Immersve.algo.ts:442
	// sender: card
	frame_dig -2 // card: Address
	itxn_field Sender

	// src/Immersve.algo.ts:443
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// src/Immersve.algo.ts:444
	// xferAsset: asset
	frame_dig -3 // asset: AssetID
	itxn_field XferAsset

	// src/Immersve.algo.ts:445
	// assetAmount: amount
	frame_dig -4 // amount: uint64
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/Immersve.algo.ts:448
	// this.Debit.log({
	//             card: card,
	//             asset: asset,
	//             amount: amount,
	//         })
	byte 0x6e40a4c4 // Debit(address,uint64,uint64)
	frame_dig -2 // card: Address
	frame_dig -3 // asset: AssetID
	itob
	concat
	frame_dig -4 // amount: uint64
	itob
	concat
	concat
	log
	retsub

// cardRefund(string,address,uint64,uint64)void
*abi_route_cardRefund:
	// amount: uint64
	txna ApplicationArgs 4
	btoi

	// asset: uint64
	txna ApplicationArgs 3
	btoi

	// card: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// partner: string
	txna ApplicationArgs 1
	extract 2 0

	// execute cardRefund(string,address,uint64,uint64)void
	callsub cardRefund
	int 1
	return

// cardRefund(partner: string, card: Address, asset: AssetID, amount: uint64): void
//
// Refunds a specified amount of an asset to a card account.
// Only the owner of the contract can perform this operation.
//
// @param card - The card account to refund the asset to.
// @param amount - The amount of the asset to refund.
cardRefund:
	proto 4 0

	// src/Immersve.algo.ts:463
	// this.onlyOwner()
	callsub onlyOwner

	// src/Immersve.algo.ts:465
	// sendAssetTransfer({
	//             sender: this.partners(partner).value,
	//             assetReceiver: card,
	//             xferAsset: asset,
	//             assetAmount: amount,
	//         })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// src/Immersve.algo.ts:466
	// sender: this.partners(partner).value
	byte 0x70 // "p"
	frame_dig -1 // partner: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	box_get
	assert
	itxn_field Sender

	// src/Immersve.algo.ts:467
	// assetReceiver: card
	frame_dig -2 // card: Address
	itxn_field AssetReceiver

	// src/Immersve.algo.ts:468
	// xferAsset: asset
	frame_dig -3 // asset: AssetID
	itxn_field XferAsset

	// src/Immersve.algo.ts:469
	// assetAmount: amount
	frame_dig -4 // amount: uint64
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/Immersve.algo.ts:472
	// this.Refund.log({
	//             card: card,
	//             asset: asset,
	//             amount: amount,
	//         })
	byte 0xf4f52ad3 // Refund(address,uint64,uint64)
	frame_dig -2 // card: Address
	frame_dig -3 // asset: AssetID
	itob
	concat
	frame_dig -4 // amount: uint64
	itob
	concat
	concat
	log
	retsub

// settle(address,uint64,uint64)void
*abi_route_settle:
	// amount: uint64
	txna ApplicationArgs 3
	btoi

	// asset: uint64
	txna ApplicationArgs 2
	btoi

	// recipient: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute settle(address,uint64,uint64)void
	callsub settle
	int 1
	return

// settle(recipient: Address, asset: AssetID, amount: uint64): void
//
// Settles a payment by transferring an asset to the specified recipient.
// Only the owner of the contract can call this function.
//
// @param recipient The address of the recipient.
// @param amount The amount of the asset to be transferred.
settle:
	proto 3 0

	// src/Immersve.algo.ts:487
	// this.onlyOwner()
	callsub onlyOwner

	// src/Immersve.algo.ts:489
	// sendAssetTransfer({
	//             sender: this.app.address,
	//             assetReceiver: recipient,
	//             xferAsset: asset,
	//             assetAmount: amount,
	//         })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// src/Immersve.algo.ts:490
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// src/Immersve.algo.ts:491
	// assetReceiver: recipient
	frame_dig -1 // recipient: Address
	itxn_field AssetReceiver

	// src/Immersve.algo.ts:492
	// xferAsset: asset
	frame_dig -2 // asset: AssetID
	itxn_field XferAsset

	// src/Immersve.algo.ts:493
	// assetAmount: amount
	frame_dig -3 // amount: uint64
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/Immersve.algo.ts:496
	// this.Settlement.log({
	//             asset: asset,
	//             amount: amount,
	//         })
	byte 0x8b66e589 // Settlement(uint64,uint64)
	frame_dig -2 // asset: AssetID
	itob
	frame_dig -3 // amount: uint64
	itob
	concat
	concat
	log
	retsub

// cardEnableAsset(pay,string,address,uint64)void
*abi_route_cardEnableAsset:
	// asset: uint64
	txna ApplicationArgs 3
	btoi

	// card: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// partner: string
	txna ApplicationArgs 1
	extract 2 0

	// mbr: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==
	assert

	// execute cardEnableAsset(pay,string,address,uint64)void
	callsub cardEnableAsset
	int 1
	return

// cardEnableAsset(mbr: PayTxn, partner: string, card: Address, asset: AssetID): void
//
// Allows the depositor (or owner) to OptIn to an asset, increasing the minimum balance requirement of the account
//
// @param partner Funding Channel name
// @param card Address to add asset to
// @param asset Asset to add
cardEnableAsset:
	proto 4 0

	// src/Immersve.algo.ts:511
	// assert(this.isOwner() || this.isCardHolder(partner, card))
	callsub isOwner
	dup
	bnz *skip_or0
	frame_dig -3 // card: Address
	frame_dig -2 // partner: string
	callsub isCardHolder
	||

*skip_or0:
	assert

	// src/Immersve.algo.ts:517
	// verifyPayTxn(mbr, {
	//             receiver: this.app.address,
	//             amount: globals.assetOptInMinBalance,
	//         })
	// verify receiver
	frame_dig -1 // mbr: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==
	assert

	// verify amount
	frame_dig -1 // mbr: PayTxn
	gtxns Amount
	global AssetOptInMinBalance
	==
	assert

	// src/Immersve.algo.ts:522
	// sendPayment({
	//             receiver: card,
	//             amount: globals.assetOptInMinBalance,
	//         })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// src/Immersve.algo.ts:523
	// receiver: card
	frame_dig -3 // card: Address
	itxn_field Receiver

	// src/Immersve.algo.ts:524
	// amount: globals.assetOptInMinBalance
	global AssetOptInMinBalance
	itxn_field Amount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/Immersve.algo.ts:527
	// sendAssetTransfer({
	//             sender: card,
	//             assetReceiver: card,
	//             xferAsset: asset,
	//             assetAmount: 0,
	//         })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// src/Immersve.algo.ts:528
	// sender: card
	frame_dig -3 // card: Address
	itxn_field Sender

	// src/Immersve.algo.ts:529
	// assetReceiver: card
	frame_dig -3 // card: Address
	itxn_field AssetReceiver

	// src/Immersve.algo.ts:530
	// xferAsset: asset
	frame_dig -4 // asset: AssetID
	itxn_field XferAsset

	// src/Immersve.algo.ts:531
	// assetAmount: 0
	int 0
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// cardDisableAsset(string,address,uint64)void
*abi_route_cardDisableAsset:
	// asset: uint64
	txna ApplicationArgs 3
	btoi

	// card: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// partner: string
	txna ApplicationArgs 1
	extract 2 0

	// execute cardDisableAsset(string,address,uint64)void
	callsub cardDisableAsset
	int 1
	return

// cardDisableAsset(partner: string, card: Address, asset: AssetID): void
//
// Allows the depositor (or owner) to CloseOut of an asset, reducing the minimum balance requirement of the account
//
// @param partner - The funding channel associated with the card.
// @param card - The address of the card.
// @param asset - The ID of the asset to be removed.
cardDisableAsset:
	proto 3 0

	// src/Immersve.algo.ts:543
	// assert(this.isOwner() || this.isCardHolder(partner, card))
	callsub isOwner
	dup
	bnz *skip_or1
	frame_dig -2 // card: Address
	frame_dig -1 // partner: string
	callsub isCardHolder
	||

*skip_or1:
	assert

	// src/Immersve.algo.ts:545
	// sendAssetTransfer({
	//             sender: card,
	//             assetReceiver: card,
	//             assetCloseTo: card,
	//             xferAsset: asset,
	//             assetAmount: 0,
	//         })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// src/Immersve.algo.ts:546
	// sender: card
	frame_dig -2 // card: Address
	itxn_field Sender

	// src/Immersve.algo.ts:547
	// assetReceiver: card
	frame_dig -2 // card: Address
	itxn_field AssetReceiver

	// src/Immersve.algo.ts:548
	// assetCloseTo: card
	frame_dig -2 // card: Address
	itxn_field AssetCloseTo

	// src/Immersve.algo.ts:549
	// xferAsset: asset
	frame_dig -3 // asset: AssetID
	itxn_field XferAsset

	// src/Immersve.algo.ts:550
	// assetAmount: 0
	int 0
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/Immersve.algo.ts:553
	// sendPayment({
	//             sender: card,
	//             receiver: this.txn.sender,
	//             amount: globals.assetOptInMinBalance,
	//         })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// src/Immersve.algo.ts:554
	// sender: card
	frame_dig -2 // card: Address
	itxn_field Sender

	// src/Immersve.algo.ts:555
	// receiver: this.txn.sender
	txn Sender
	itxn_field Receiver

	// src/Immersve.algo.ts:556
	// amount: globals.assetOptInMinBalance
	global AssetOptInMinBalance
	itxn_field Amount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// cardWithdrawalRequest(string,address,uint64,uint64)byte[32]
*abi_route_cardWithdrawalRequest:
	// The ABI return prefix
	byte 0x151f7c75

	// amount: uint64
	txna ApplicationArgs 4
	btoi

	// asset: uint64
	txna ApplicationArgs 3
	btoi

	// card: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// partner: string
	txna ApplicationArgs 1
	extract 2 0

	// execute cardWithdrawalRequest(string,address,uint64,uint64)byte[32]
	callsub cardWithdrawalRequest
	concat
	log
	int 1
	return

// cardWithdrawalRequest(partner: string, card: Address, asset: AssetID, amount: uint64): bytes32
//
// Allows the Card Holder (or contract owner) to send an amount of assets from the account
// @param partner Funding Channel name
// @param card Address to withdraw from
// @param asset Asset to withdraw
// @param amount Amount to withdraw
// @returns Withdrawal hash used for completing or cancelling the withdrawal
cardWithdrawalRequest:
	proto 4 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// src/Immersve.algo.ts:571
	// assert(this.isOwner() || this.isCardHolder(partner, card))
	callsub isOwner
	dup
	bnz *skip_or2
	frame_dig -2 // card: Address
	frame_dig -1 // partner: string
	callsub isCardHolder
	||

*skip_or2:
	assert

	// src/Immersve.algo.ts:573
	// withdrawal: WithdrawalRequest = {
	//             nonce: this.withdrawal_nonce(this.txn.sender).value,
	//             round: globals.round + this.withdrawal_wait_time.value,
	//             asset: asset,
	//             amount: amount,
	//         }
	txn Sender
	byte 0x6e // "n"
	app_local_get
	itob
	global Round
	byte 0x77 // "w"
	app_global_get
	+
	itob
	concat
	frame_dig -3 // asset: AssetID
	itob
	concat
	frame_dig -4 // amount: uint64
	itob
	concat
	frame_bury 0 // withdrawal: WithdrawalRequest

	// src/Immersve.algo.ts:579
	// this.withdrawal_nonce(this.txn.sender).value = this.withdrawal_nonce(this.txn.sender).value + 1
	txn Sender
	byte 0x6e // "n"
	txn Sender
	byte 0x6e // "n"
	app_local_get
	int 1
	+
	app_local_put

	// src/Immersve.algo.ts:580
	// withdrawal_hash = sha256(rawBytes(withdrawal))
	frame_dig 0 // withdrawal: WithdrawalRequest
	sha256
	frame_bury 1 // withdrawal_hash: byte[32]

	// src/Immersve.algo.ts:582
	// this.withdrawals(this.txn.sender, withdrawal_hash).value = withdrawal
	txn Sender
	frame_dig 1 // withdrawal_hash: byte[32]
	frame_dig 0 // withdrawal: WithdrawalRequest
	app_local_put

	// src/Immersve.algo.ts:584
	// return withdrawal_hash;
	frame_dig 1 // withdrawal_hash: byte[32]

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// cardWithdrawalCancel(string,address,byte[32])void
*abi_route_cardWithdrawalCancel:
	// withdrawal_hash: byte[32]
	txna ApplicationArgs 3
	dup
	len
	int 32
	==
	assert

	// card: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// partner: string
	txna ApplicationArgs 1
	extract 2 0

	// execute cardWithdrawalCancel(string,address,byte[32])void
	callsub cardWithdrawalCancel
	int 1
	return

// cardWithdrawalCancel(partner: string, card: Address, withdrawal_hash: bytes32): void
//
// Allows the Card Holder (or contract owner) to cancel a withdrawal request
// @param partner Funding Channel name
// @param card Address to withdraw from
// @param withdrawal_hash Hash of the withdrawal request
cardWithdrawalCancel:
	proto 3 0

	// src/Immersve.algo.ts:594
	// assert(this.isOwner() || this.isCardHolder(partner, card))
	callsub isOwner
	dup
	bnz *skip_or3
	frame_dig -2 // card: Address
	frame_dig -1 // partner: string
	callsub isCardHolder
	||

*skip_or3:
	assert

	// src/Immersve.algo.ts:596
	// this.withdrawals(this.txn.sender, withdrawal_hash).delete()
	txn Sender
	frame_dig -3 // withdrawal_hash: bytes32
	app_local_del
	retsub

// cardWithdraw(string,address,address,byte[32])void
*abi_route_cardWithdraw:
	// withdrawal_hash: byte[32]
	txna ApplicationArgs 4
	dup
	len
	int 32
	==
	assert

	// recipient: address
	txna ApplicationArgs 3
	dup
	len
	int 32
	==
	assert

	// card: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// partner: string
	txna ApplicationArgs 1
	extract 2 0

	// execute cardWithdraw(string,address,address,byte[32])void
	callsub cardWithdraw
	int 1
	return

// cardWithdraw(partner: string, card: Address, recipient: Address, withdrawal_hash: bytes32): void
//
// Allows the Card Holder to send an amount of assets from the account
// @param partner Funding Channel name
// @param card Address to withdraw from
// @param recipient Receiver of the assets being withdrawn
// @param withdrawal_hash Hash of the withdrawal request
cardWithdraw:
	proto 4 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// src/Immersve.algo.ts:609
	// assert(this.isOwner() || this.isCardHolder(partner, card))
	callsub isOwner
	dup
	bnz *skip_or4
	frame_dig -2 // card: Address
	frame_dig -1 // partner: string
	callsub isCardHolder
	||

*skip_or4:
	assert

	// src/Immersve.algo.ts:611
	// withdrawal = this.withdrawals(this.txn.sender, withdrawal_hash).value
	frame_dig -4 // withdrawal_hash: bytes32
	frame_bury 0 // storage key//withdrawal

	// src/Immersve.algo.ts:611
	// withdrawal = this.withdrawals(this.txn.sender, withdrawal_hash).value
	txn Sender
	frame_bury 1 // storage account//withdrawal

	// src/Immersve.algo.ts:613
	// assert(globals.round >= withdrawal.round || this.isOwner())
	global Round
	frame_dig 1 // storage account//withdrawal
	frame_dig 0 // storage key//withdrawal
	app_local_get
	extract 8 8
	btoi
	>=
	dup
	bnz *skip_or5
	callsub isOwner
	||

*skip_or5:
	assert

	// src/Immersve.algo.ts:618
	// sendAssetTransfer({
	//             sender: card,
	//             assetReceiver: recipient,
	//             xferAsset: withdrawal.asset,
	//             assetAmount: withdrawal.amount,
	//         })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// src/Immersve.algo.ts:619
	// sender: card
	frame_dig -2 // card: Address
	itxn_field Sender

	// src/Immersve.algo.ts:620
	// assetReceiver: recipient
	frame_dig -3 // recipient: Address
	itxn_field AssetReceiver

	// src/Immersve.algo.ts:621
	// xferAsset: withdrawal.asset
	frame_dig 1 // storage account//withdrawal
	frame_dig 0 // storage key//withdrawal
	app_local_get
	extract 16 8
	btoi
	itxn_field XferAsset

	// src/Immersve.algo.ts:622
	// assetAmount: withdrawal.amount
	frame_dig 1 // storage account//withdrawal
	frame_dig 0 // storage key//withdrawal
	app_local_get
	extract 24 8
	btoi
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/Immersve.algo.ts:625
	// this.withdrawals(this.txn.sender, withdrawal_hash).delete()
	txn Sender
	frame_dig -4 // withdrawal_hash: bytes32
	app_local_del
	retsub

*create_NoOp:
	method "deploy(address)address"
	txna ApplicationArgs 0
	match *abi_route_deploy
	err

*call_NoOp:
	method "owner()address"
	method "transferOwnership(address)void"
	method "setWithdrawalRounds(uint64)void"
	method "partnerCreate(pay,string)address"
	method "partnerClose(string)void"
	method "cardCreate(pay,string,address)address"
	method "cardClose(string,address,address)void"
	method "cardRecover(string,address,address)void"
	method "assetAllowlistAdd(pay,uint64)void"
	method "assetAllowlistRemove(uint64)void"
	method "partnerAcceptAsset(pay,string,uint64)void"
	method "partnerRejectAsset(string,uint64)void"
	method "cardDebit(string,address,uint64,uint64)void"
	method "cardRefund(string,address,uint64,uint64)void"
	method "settle(address,uint64,uint64)void"
	method "cardEnableAsset(pay,string,address,uint64)void"
	method "cardDisableAsset(string,address,uint64)void"
	method "cardWithdrawalRequest(string,address,uint64,uint64)byte[32]"
	method "cardWithdrawalCancel(string,address,byte[32])void"
	method "cardWithdraw(string,address,address,byte[32])void"
	txna ApplicationArgs 0
	match *abi_route_owner *abi_route_transferOwnership *abi_route_setWithdrawalRounds *abi_route_partnerCreate *abi_route_partnerClose *abi_route_cardCreate *abi_route_cardClose *abi_route_cardRecover *abi_route_assetAllowlistAdd *abi_route_assetAllowlistRemove *abi_route_partnerAcceptAsset *abi_route_partnerRejectAsset *abi_route_cardDebit *abi_route_cardRefund *abi_route_settle *abi_route_cardEnableAsset *abi_route_cardDisableAsset *abi_route_cardWithdrawalRequest *abi_route_cardWithdrawalCancel *abi_route_cardWithdraw
	err

*call_OptIn:
	method "cardWithdrawalRequest(string,address,uint64,uint64)byte[32]"
	txna ApplicationArgs 0
	match *abi_route_cardWithdrawalRequest
	err

*call_CloseOut:
	method "cardWithdraw(string,address,address,byte[32])void"
	txna ApplicationArgs 0
	match *abi_route_cardWithdraw
	err

*call_UpdateApplication:
	method "update()void"
	txna ApplicationArgs 0
	match *abi_route_update
	err

*call_DeleteApplication:
	method "destroy()void"
	txna ApplicationArgs 0
	match *abi_route_destroy
	err

*process_static_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -1 // element
	concat
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub

*process_dynamic_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -2 // head offset
	concat
	frame_bury -4 // tuple head
	frame_dig -1 // element
	dup
	len
	frame_dig -2 // head offset
	btoi
	+
	itob
	extract 6 2
	frame_bury -2 // head offset
	frame_dig -3 // tuple tail
	swap
	concat
	frame_bury -3 // tuple tail
	frame_dig -4 // tuple head
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub