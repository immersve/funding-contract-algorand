#pragma version 10

// This TEAL was generated by TEALScript v0.90.0
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
int 6
*
txn OnCompletion
+
switch *call_NoOp *call_OptIn *call_CloseOut *NOT_IMPLEMENTED *call_UpdateApplication *call_DeleteApplication *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	err

// onlyOwner(): void
//
// Assert the transaction sender is the owner of the contract.
onlyOwner:
	proto 0 0

	// src/roles/Ownable.algo.ts:53
	// assert(this.txn.sender === this._owner.value, 'SENDER_NOT_ALLOWED')
	txn Sender
	byte 0x5f6f776e6572 // "_owner"
	app_global_get
	==

	// SENDER_NOT_ALLOWED
	assert
	retsub

// isOwner(): boolean
//
// Checks if the current transaction sender is the owner.
// @returns boolean True if the sender is the owner, false otherwise.
isOwner:
	proto 0 1

	// src/roles/Ownable.algo.ts:61
	// return this.txn.sender === this._owner.value;
	txn Sender
	byte 0x5f6f776e6572 // "_owner"
	app_global_get
	==
	retsub

// owner()address
*abi_route_owner:
	// The ABI return prefix
	byte 0x151f7c75

	// execute owner()address
	callsub owner
	concat
	log
	int 1
	return

// owner(): Address
owner:
	proto 0 1

	// src/roles/Ownable.algo.ts:67
	// return this._owner.value;
	byte 0x5f6f776e6572 // "_owner"
	app_global_get
	retsub

// _transferOwnership(newOwner: Address): void
//
// Transfers the ownership of the contract to a new owner.
// @param newOwner The address of the new owner.
_transferOwnership:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/roles/Ownable.algo.ts:76
	// previousOwner = this._owner.exists ? this._owner.value : globals.zeroAddress
	txna Applications 0
	byte 0x5f6f776e6572 // "_owner"
	app_global_get_ex
	swap
	pop
	bz *ternary1_false
	byte 0x5f6f776e6572 // "_owner"
	app_global_get
	b *ternary1_end

*ternary1_false:
	global ZeroAddress

*ternary1_end:
	frame_bury 0 // previousOwner: address

	// src/roles/Ownable.algo.ts:77
	// this._owner.value = newOwner
	byte 0x5f6f776e6572 // "_owner"
	frame_dig -1 // newOwner: Address
	app_global_put

	// src/roles/Ownable.algo.ts:79
	// this.OwnershipTransferred.log({
	//             previousOwner: previousOwner,
	//             newOwner: newOwner,
	//         })
	byte 0x9a223efb // OwnershipTransferred(address,address)
	frame_dig 0 // previousOwner: address
	frame_dig -1 // newOwner: Address
	concat
	concat
	log
	retsub

// transferOwnership(address)void
*abi_route_transferOwnership:
	// newOwner: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute transferOwnership(address)void
	callsub transferOwnership
	int 1
	return

// transferOwnership(newOwner: Address): void
//
// Transfers the ownership of the contract to a new owner.
// Requires the caller to be the current owner.
//
// @param newOwner The address of the new owner.
transferOwnership:
	proto 1 0

	// src/roles/Ownable.algo.ts:93
	// this.onlyOwner()
	callsub onlyOwner

	// src/roles/Ownable.algo.ts:95
	// this._transferOwnership(newOwner)
	frame_dig -1 // newOwner: Address
	callsub _transferOwnership
	retsub

// whenNotPaused(): void
//
// @dev Modifier to make a function callable only when the contract is not paused.
whenNotPaused:
	proto 0 0

	// src/roles/Pausable.algo.ts:49
	// assert(!this.paused.value)
	byte 0x706175736564 // "paused"
	app_global_get
	int 0
	getbit
	!
	assert
	retsub

// onlyPauser(): void
//
// @dev throws if called by any account other than the pauser
onlyPauser:
	proto 0 0

	// src/roles/Pausable.algo.ts:56
	// assert(this.txn.sender === this._pauser.value)
	txn Sender
	byte 0x5f706175736572 // "_pauser"
	app_global_get
	==
	assert
	retsub

// pauser()address
*abi_route_pauser:
	// The ABI return prefix
	byte 0x151f7c75

	// execute pauser()address
	callsub pauser
	concat
	log
	int 1
	return

// pauser(): Address
//
// @notice Returns current pauser
// @return Pauser's address
pauser:
	proto 0 1

	// src/roles/Pausable.algo.ts:65
	// return this._pauser.value;
	byte 0x5f706175736572 // "_pauser"
	app_global_get
	retsub

// pause()void
*abi_route_pause:
	// execute pause()void
	callsub pause
	int 1
	return

// pause(): void
//
// @dev called by the owner to pause, triggers stopped state
pause:
	proto 0 0

	// src/roles/Pausable.algo.ts:73
	// this.onlyPauser()
	callsub onlyPauser

	// src/roles/Pausable.algo.ts:75
	// this.paused.value = true
	byte 0x706175736564 // "paused"
	int 1
	byte 0x00
	int 0
	uncover 2
	setbit
	app_global_put

	// src/roles/Pausable.algo.ts:76
	// this.Pause.log({})
	byte 0xcf23a30f // Pause()
	concat
	log
	retsub

// unpause()void
*abi_route_unpause:
	// execute unpause()void
	callsub unpause
	int 1
	return

// unpause(): void
//
// @dev called by the owner to unpause, returns to normal state
unpause:
	proto 0 0

	// src/roles/Pausable.algo.ts:83
	// this.onlyPauser()
	callsub onlyPauser

	// src/roles/Pausable.algo.ts:85
	// this.paused.value = false
	byte 0x706175736564 // "paused"
	int 0
	byte 0x00
	int 0
	uncover 2
	setbit
	app_global_put

	// src/roles/Pausable.algo.ts:86
	// this.Unpause.log({})
	byte 0xb163ee0b // Unpause()
	concat
	log
	retsub

// updatePauser(address)void
*abi_route_updatePauser:
	// _newPauser: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute updatePauser(address)void
	callsub updatePauser
	int 1
	return

// updatePauser(_newPauser: Address): void
//
// @dev update the pauser role
updatePauser:
	proto 1 0

	// src/roles/Pausable.algo.ts:93
	// this.onlyPauser()
	callsub onlyPauser

	// src/roles/Pausable.algo.ts:95
	// assert(_newPauser !== globals.zeroAddress)
	frame_dig -1 // _newPauser: Address
	global ZeroAddress
	!=
	assert

	// src/roles/Pausable.algo.ts:96
	// this._pauser.value = _newPauser
	byte 0x5f706175736572 // "_pauser"
	frame_dig -1 // _newPauser: Address
	app_global_put

	// src/roles/Pausable.algo.ts:97
	// this.PauserChanged.log({ newAddress: this._pauser.value })
	byte 0xcc40923c // PauserChanged(address)
	byte 0x5f706175736572 // "_pauser"
	app_global_get
	concat
	log
	retsub

// isCardFundOwner(cardFund: Address): boolean
//
// Check if the current transaction sender is the Card Fund holder/owner
// @param cardFund Card Fund address
// @returns True if the sender is the Card Holder of the card
isCardFundOwner:
	proto 1 1

	// src/Immersve.algo.ts:267
	// assert(this.card_funds(cardFund).exists, 'CARD_FUND_NOT_FOUND')
	byte 0x6366 // "cf"
	frame_dig -1 // cardFund: Address
	concat
	box_len
	swap
	pop

	// CARD_FUND_NOT_FOUND
	assert

	// src/Immersve.algo.ts:268
	// return this.card_funds(cardFund).value.owner === this.txn.sender;
	int 32 // headOffset
	int 32
	byte 0x6366 // "cf"
	frame_dig -1 // cardFund: Address
	concat
	cover 2
	box_extract
	txn Sender
	==
	retsub

// cardFundAssetOptIn(cardFund: Address, asset: AssetID): void
//
// Opt-in a Card Fund into an asset. Minimum balance requirement must be met prior to calling this function.
// @param cardFund Card Fund address
// @param asset Asset to opt-in to
cardFundAssetOptIn:
	proto 2 0

	// src/Immersve.algo.ts:278
	// assert(this.app.address.isOptedInToAsset(asset), 'ASSET_NOT_OPTED_IN')
	global CurrentApplicationAddress
	frame_dig -2 // asset: AssetID
	asset_holding_get AssetBalance
	swap
	pop

	// ASSET_NOT_OPTED_IN
	assert

	// src/Immersve.algo.ts:280
	// sendAssetTransfer({
	//             sender: cardFund,
	//             assetReceiver: cardFund,
	//             xferAsset: asset,
	//             assetAmount: 0,
	//         })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// src/Immersve.algo.ts:281
	// sender: cardFund
	frame_dig -1 // cardFund: Address
	itxn_field Sender

	// src/Immersve.algo.ts:282
	// assetReceiver: cardFund
	frame_dig -1 // cardFund: Address
	itxn_field AssetReceiver

	// src/Immersve.algo.ts:283
	// xferAsset: asset
	frame_dig -2 // asset: AssetID
	itxn_field XferAsset

	// src/Immersve.algo.ts:284
	// assetAmount: 0
	int 0
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/Immersve.algo.ts:287
	// this.CardFundAssetEnabled.log({
	//             cardFund: cardFund,
	//             asset: asset,
	//         })
	byte 0x248a051e // CardFundAssetEnabled(address,uint64)
	frame_dig -1 // cardFund: Address
	frame_dig -2 // asset: AssetID
	itob
	concat
	concat
	log
	retsub

// cardFundAssetCloseOut(cardFund: Address, asset: AssetID): void
cardFundAssetCloseOut:
	proto 2 0

	// src/Immersve.algo.ts:294
	// sendAssetTransfer({
	//             sender: cardFund,
	//             assetReceiver: cardFund,
	//             assetCloseTo: cardFund,
	//             xferAsset: asset,
	//             assetAmount: 0,
	//         })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// src/Immersve.algo.ts:295
	// sender: cardFund
	frame_dig -1 // cardFund: Address
	itxn_field Sender

	// src/Immersve.algo.ts:296
	// assetReceiver: cardFund
	frame_dig -1 // cardFund: Address
	itxn_field AssetReceiver

	// src/Immersve.algo.ts:297
	// assetCloseTo: cardFund
	frame_dig -1 // cardFund: Address
	itxn_field AssetCloseTo

	// src/Immersve.algo.ts:298
	// xferAsset: asset
	frame_dig -2 // asset: AssetID
	itxn_field XferAsset

	// src/Immersve.algo.ts:299
	// assetAmount: 0
	int 0
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/Immersve.algo.ts:302
	// sendPayment({
	//             sender: cardFund,
	//             receiver: this.txn.sender,
	//             amount: this.getCardFundAssetMbr(),
	//         })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// src/Immersve.algo.ts:303
	// sender: cardFund
	frame_dig -1 // cardFund: Address
	itxn_field Sender

	// src/Immersve.algo.ts:304
	// receiver: this.txn.sender
	txn Sender
	itxn_field Receiver

	// src/Immersve.algo.ts:305
	// amount: this.getCardFundAssetMbr()
	callsub getCardFundAssetMbr
	itxn_field Amount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/Immersve.algo.ts:308
	// this.CardFundAssetDisabled.log({
	//             cardFund: cardFund,
	//             asset: asset,
	//         })
	byte 0xd1531678 // CardFundAssetDisabled(address,uint64)
	frame_dig -1 // cardFund: Address
	frame_dig -2 // asset: AssetID
	itob
	concat
	concat
	log
	retsub

// withdrawFunds(withdrawal: WithdrawalRequest): void
withdrawFunds:
	proto 1 0

	// src/Immersve.algo.ts:315
	// sendAssetTransfer({
	//             sender: withdrawal.cardFund,
	//             assetReceiver: withdrawal.recipient,
	//             xferAsset: withdrawal.asset,
	//             assetAmount: withdrawal.amount,
	//         })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// src/Immersve.algo.ts:316
	// sender: withdrawal.cardFund
	frame_dig -1 // withdrawal: WithdrawalRequest
	extract 0 32
	itxn_field Sender

	// src/Immersve.algo.ts:317
	// assetReceiver: withdrawal.recipient
	frame_dig -1 // withdrawal: WithdrawalRequest
	extract 32 32
	itxn_field AssetReceiver

	// src/Immersve.algo.ts:318
	// xferAsset: withdrawal.asset
	frame_dig -1 // withdrawal: WithdrawalRequest
	extract 64 8
	btoi
	itxn_field XferAsset

	// src/Immersve.algo.ts:319
	// assetAmount: withdrawal.amount
	frame_dig -1 // withdrawal: WithdrawalRequest
	extract 72 8
	btoi
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/Immersve.algo.ts:323
	// this.Withdrawal.log({
	//             cardFund: withdrawal.cardFund,
	//             recipient: withdrawal.recipient,
	//             asset: withdrawal.asset,
	//             amount: withdrawal.amount,
	//             nonce: withdrawal.nonce,
	//         })
	byte 0x3b7b360b // Withdrawal(address,address,uint64,uint64,uint64)
	frame_dig -1 // withdrawal: WithdrawalRequest
	extract 0 32
	frame_dig -1 // withdrawal: WithdrawalRequest
	extract 32 32
	concat
	frame_dig -1 // withdrawal: WithdrawalRequest
	extract 64 8
	btoi
	itob
	concat
	frame_dig -1 // withdrawal: WithdrawalRequest
	extract 72 8
	btoi
	itob
	concat
	frame_dig -1 // withdrawal: WithdrawalRequest
	extract 88 8
	btoi
	itob
	concat
	concat
	log
	retsub

// updateSettlementAddress(asset: AssetID, newSettlementAddress: Address): void
updateSettlementAddress:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/Immersve.algo.ts:333
	// oldSettlementAddress = this.settlement_address(asset).exists
	//             ? this.settlement_address(asset).value
	//             : globals.zeroAddress
	byte 0x7361 // "sa"
	frame_dig -1 // asset: AssetID
	itob
	concat
	box_len
	swap
	pop
	bz *ternary3_false
	byte 0x7361 // "sa"
	frame_dig -1 // asset: AssetID
	itob
	concat
	box_get
	assert
	b *ternary3_end

*ternary3_false:
	global ZeroAddress

*ternary3_end:
	frame_bury 0 // oldSettlementAddress: address

	// src/Immersve.algo.ts:336
	// this.settlement_address(asset).value = newSettlementAddress
	byte 0x7361 // "sa"
	frame_dig -1 // asset: AssetID
	itob
	concat
	frame_dig -2 // newSettlementAddress: Address
	box_put

	// src/Immersve.algo.ts:338
	// this.SettlementAddressChanged.log({
	//             oldSettlementAddress: oldSettlementAddress,
	//             newSettlementAddress: newSettlementAddress,
	//         })
	byte 0xfd535358 // SettlementAddressChanged(address,address)
	frame_dig 0 // oldSettlementAddress: address
	frame_dig -2 // newSettlementAddress: Address
	concat
	concat
	log
	retsub

// deploy(address)address
*abi_route_deploy:
	// The ABI return prefix
	byte 0x151f7c75

	// owner: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute deploy(address)address
	callsub deploy
	concat
	log
	int 1
	return

// deploy(owner: Address): Address
//
// Deploy a partner channel, setting the owner as provided
deploy:
	proto 1 1

	// src/Immersve.algo.ts:350
	// this._transferOwnership(owner)
	frame_dig -1 // owner: Address
	callsub _transferOwnership

	// src/Immersve.algo.ts:351
	// this._pauser.value = this.txn.sender
	byte 0x5f706175736572 // "_pauser"
	txn Sender
	app_global_put

	// src/Immersve.algo.ts:353
	// return this.app.address;
	global CurrentApplicationAddress
	retsub

// update()void
*abi_route_update:
	// execute update()void
	callsub update
	int 1
	return

// update(): void
//
// Allows the owner to update the smart contract
update:
	proto 0 0

	// src/Immersve.algo.ts:361
	// this.onlyOwner()
	callsub onlyOwner
	retsub

// destroy()void
*abi_route_destroy:
	// execute destroy()void
	callsub destroy
	int 1
	return

// destroy(): void
//
// Destroy the smart contract, sending all Algo to the owner account. This can only be done if there are no active card funds
destroy:
	proto 0 0

	// src/Immersve.algo.ts:369
	// this.onlyOwner()
	callsub onlyOwner

	// src/Immersve.algo.ts:372
	// assert(!this.card_funds_active_count.value, 'CARD_FUNDS_STILL_ACTIVE')
	byte 0x63666163 // "cfac"
	app_global_get
	!

	// CARD_FUNDS_STILL_ACTIVE
	assert

	// src/Immersve.algo.ts:374
	// assert(!this.partner_channels_active_count.value, 'PARTNER_CHANNELS_STILL_ACTIVE')
	byte 0x70636163 // "pcac"
	app_global_get
	!

	// PARTNER_CHANNELS_STILL_ACTIVE
	assert

	// src/Immersve.algo.ts:376
	// sendPayment({
	//             receiver: this.app.address,
	//             amount: 0,
	//             closeRemainderTo: this.owner(),
	//         })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// src/Immersve.algo.ts:377
	// receiver: this.app.address
	global CurrentApplicationAddress
	itxn_field Receiver

	// src/Immersve.algo.ts:378
	// amount: 0
	int 0
	itxn_field Amount

	// src/Immersve.algo.ts:379
	// closeRemainderTo: this.owner()
	callsub owner
	itxn_field CloseRemainderTo

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// setWithdrawalTimeout(uint64)void
*abi_route_setWithdrawalTimeout:
	// seconds: uint64
	txna ApplicationArgs 1
	btoi

	// execute setWithdrawalTimeout(uint64)void
	callsub setWithdrawalTimeout
	int 1
	return

// setWithdrawalTimeout(seconds: uint64): void
//
// Set the number of seconds a withdrawal request must wait until being withdrawn
// @param seconds New number of seconds to wait
setWithdrawalTimeout:
	proto 1 0

	// src/Immersve.algo.ts:389
	// this.onlyOwner()
	callsub onlyOwner

	// src/Immersve.algo.ts:391
	// this.withdrawal_wait_time.value = seconds
	byte 0x777774 // "wwt"
	frame_dig -1 // seconds: uint64
	app_global_put
	retsub

// setEarlyWithdrawalPubkey(byte[32])void
*abi_route_setEarlyWithdrawalPubkey:
	// pubkey: byte[32]
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute setEarlyWithdrawalPubkey(byte[32])void
	callsub setEarlyWithdrawalPubkey
	int 1
	return

// setEarlyWithdrawalPubkey(pubkey: bytes32): void
//
// Sets the early withdrawal public key.
// @param pubkey - The public key to set.
setEarlyWithdrawalPubkey:
	proto 1 0

	// src/Immersve.algo.ts:399
	// this.onlyOwner()
	callsub onlyOwner

	// src/Immersve.algo.ts:401
	// this.early_withdrawal_pubkey.value = pubkey
	byte 0x6577706b // "ewpk"
	frame_dig -1 // pubkey: bytes32
	app_global_put
	retsub

// getPartnerChannelMbr(string)uint64
*abi_route_getPartnerChannelMbr:
	// The ABI return prefix
	byte 0x151f7c75

	// partnerChannelName: string
	txna ApplicationArgs 1
	extract 2 0

	// execute getPartnerChannelMbr(string)uint64
	callsub getPartnerChannelMbr
	itob
	concat
	log
	int 1
	return

// getPartnerChannelMbr(partnerChannelName: string): uint64
//
// Retrieves the minimum balance requirement for creating a partner channel account.
// @param partnerChannelName - The name of the partner channel.
// @returns The minimum balance requirement for creating a partner channel account.
getPartnerChannelMbr:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/Immersve.algo.ts:410
	// boxCost = 2500 + 400 * (3 + 32 + len(partnerChannelName))
	int 2500
	int 400
	int 35
	frame_dig -1 // partnerChannelName: string
	len
	+
	*
	+
	frame_bury 0 // boxCost: uint64

	// src/Immersve.algo.ts:411
	// return globals.minBalance + globals.minBalance + boxCost;
	global MinBalance
	global MinBalance
	+
	frame_dig 0 // boxCost: uint64
	+

	// set the subroutine return value
	frame_bury 0
	retsub

// partnerChannelCreate(pay,string)address
*abi_route_partnerChannelCreate:
	// The ABI return prefix
	byte 0x151f7c75

	// partnerChannelName: string
	txna ApplicationArgs 1
	extract 2 0

	// mbr: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==
	assert

	// execute partnerChannelCreate(pay,string)address
	callsub partnerChannelCreate
	concat
	log
	int 1
	return

// partnerChannelCreate(mbr: PayTxn, partnerChannelName: string): Address
//
// Creates a partner channel account and associates it with the provided partner channel name.
// Only the owner of the contract can call this function.
//
// @param mbr - The PayTxn object representing the payment transaction.
// @param partnerChannelName - The name of the partner channel.
// @returns The address of the newly created partner channel account.
partnerChannelCreate:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/Immersve.algo.ts:423
	// verifyPayTxn(mbr, {
	//             receiver: this.app.address,
	//             amount: this.getPartnerChannelMbr(partnerChannelName),
	//         })
	// verify receiver
	frame_dig -1 // mbr: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==
	assert

	// verify amount
	frame_dig -1 // mbr: PayTxn
	gtxns Amount
	frame_dig -2 // partnerChannelName: string
	callsub getPartnerChannelMbr
	==
	assert

	// src/Immersve.algo.ts:429
	// partnerChannelAddr = sendMethodCall<typeof ControlledAddress.prototype.new>({
	//             onCompletion: OnCompletion.DeleteApplication,
	//             approvalProgram: ControlledAddress.approvalProgram(),
	//             clearStateProgram: ControlledAddress.clearProgram(),
	//         })
	itxn_begin
	int appl
	itxn_field TypeEnum
	method "new()address"
	itxn_field ApplicationArgs

	// src/Immersve.algo.ts:430
	// onCompletion: OnCompletion.DeleteApplication
	int 5 // DeleteApplication
	itxn_field OnCompletion

	// src/Immersve.algo.ts:431
	// approvalProgram: ControlledAddress.approvalProgram()
	byte b64 CiACAQAxGBSBBgsxGQiNDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJwCABBUffHWIAARQsCJDigABsSKyEDIKsgcjsggyDrIgI7IBszIKiYAEVh0v6jYaAI4B/80A
	itxn_field ApprovalProgram

	// src/Immersve.algo.ts:432
	// clearStateProgram: ControlledAddress.clearProgram()
	byte b64 Cg==
	itxn_field ClearStateProgram

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	int 1
	-
	itxnas Logs
	extract 4 0
	frame_bury 0 // partnerChannelAddr: address

	// src/Immersve.algo.ts:436
	// sendPayment({
	//             receiver: partnerChannelAddr,
	//             amount: globals.minBalance,
	//         })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// src/Immersve.algo.ts:437
	// receiver: partnerChannelAddr
	frame_dig 0 // partnerChannelAddr: address
	itxn_field Receiver

	// src/Immersve.algo.ts:438
	// amount: globals.minBalance
	global MinBalance
	itxn_field Amount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/Immersve.algo.ts:441
	// this.partner_channels(partnerChannelAddr).value = partnerChannelName
	byte 0x7063 // "pc"
	frame_dig 0 // partnerChannelAddr: address
	concat
	dup
	box_del
	pop
	frame_dig -2 // partnerChannelName: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	box_put

	// src/Immersve.algo.ts:444
	// this.partner_channels_active_count.value = this.partner_channels_active_count.value + 1
	byte 0x70636163 // "pcac"
	dup
	app_global_get
	int 1
	+
	app_global_put

	// src/Immersve.algo.ts:446
	// this.PartnerChannelCreated.log({
	//             partnerChannel: partnerChannelAddr,
	//             partnerChannelName: partnerChannelName,
	//         })
	byte 0x2c924dee // PartnerChannelCreated(address,string)
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x0022 // initial head offset
	frame_dig 0 // partnerChannelAddr: address
	callsub *process_static_tuple_element
	frame_dig -2 // partnerChannelName: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	concat
	log

	// src/Immersve.algo.ts:451
	// return partnerChannelAddr;
	frame_dig 0 // partnerChannelAddr: address

	// set the subroutine return value
	frame_bury 0
	retsub

// partnerChannelClose(address)void
*abi_route_partnerChannelClose:
	// partnerChannel: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute partnerChannelClose(address)void
	callsub partnerChannelClose
	int 1
	return

// partnerChannelClose(partnerChannel: Address): void
partnerChannelClose:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// src/Immersve.algo.ts:455
	// this.onlyOwner()
	callsub onlyOwner

	// src/Immersve.algo.ts:457
	// sendPayment({
	//             sender: partnerChannel,
	//             receiver: partnerChannel,
	//             amount: 0,
	//             closeRemainderTo: this.txn.sender,
	//         })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// src/Immersve.algo.ts:458
	// sender: partnerChannel
	frame_dig -1 // partnerChannel: Address
	itxn_field Sender

	// src/Immersve.algo.ts:459
	// receiver: partnerChannel
	frame_dig -1 // partnerChannel: Address
	itxn_field Receiver

	// src/Immersve.algo.ts:460
	// amount: 0
	int 0
	itxn_field Amount

	// src/Immersve.algo.ts:461
	// closeRemainderTo: this.txn.sender
	txn Sender
	itxn_field CloseRemainderTo

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/Immersve.algo.ts:464
	// partnerChannelSize = this.partner_channels(partnerChannel).size
	byte 0x7063 // "pc"
	frame_dig -1 // partnerChannel: Address
	concat
	box_len
	assert
	frame_bury 0 // partnerChannelSize: uint64

	// src/Immersve.algo.ts:465
	// boxCost = 2500 + 400 * (3 + 32 + partnerChannelSize)
	int 2500
	int 400
	int 35
	frame_dig 0 // partnerChannelSize: uint64
	+
	*
	+
	frame_bury 1 // boxCost: uint64

	// src/Immersve.algo.ts:467
	// sendPayment({
	//             receiver: this.txn.sender,
	//             amount: boxCost,
	//         })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// src/Immersve.algo.ts:468
	// receiver: this.txn.sender
	txn Sender
	itxn_field Receiver

	// src/Immersve.algo.ts:469
	// amount: boxCost
	frame_dig 1 // boxCost: uint64
	itxn_field Amount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/Immersve.algo.ts:473
	// this.partner_channels(partnerChannel).delete()
	byte 0x7063 // "pc"
	frame_dig -1 // partnerChannel: Address
	concat
	box_del

	// src/Immersve.algo.ts:476
	// this.partner_channels_active_count.value = this.partner_channels_active_count.value - 1
	byte 0x70636163 // "pcac"
	dup
	app_global_get
	int 1
	-
	app_global_put
	retsub

// getCardFundMbr(uint64)uint64
*abi_route_getCardFundMbr:
	// The ABI return prefix
	byte 0x151f7c75

	// asset: uint64
	txna ApplicationArgs 1
	btoi

	// execute getCardFundMbr(uint64)uint64
	callsub getCardFundMbr
	itob
	concat
	log
	int 1
	return

// getCardFundMbr(asset: AssetID): uint64
//
// Retrieves the minimum balance requirement for creating a card fund account.
// @param asset Asset to opt-in to. 0 = No asset opt-in
// @returns Minimum balance requirement for creating a card fund account
getCardFundMbr:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// src/Immersve.algo.ts:487
	// boxCost = 2500 + 400 * (3 + 32 + (32 + 32 + 32 + 8))
	int 58100
	frame_bury 0 // boxCost: uint64

	// src/Immersve.algo.ts:488
	// assetMbr = asset ? globals.assetOptInMinBalance : 0
	frame_dig -1 // asset: AssetID
	bz *ternary5_false
	global AssetOptInMinBalance
	b *ternary5_end

*ternary5_false:
	int 0

*ternary5_end:
	frame_bury 1 // assetMbr: uint64

	// src/Immersve.algo.ts:489
	// return globals.minBalance + assetMbr + boxCost;
	global MinBalance
	frame_dig 1 // assetMbr: uint64
	+
	frame_dig 0 // boxCost: uint64
	+

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// cardFundCreate(pay,address,uint64)address
*abi_route_cardFundCreate:
	// The ABI return prefix
	byte 0x151f7c75

	// asset: uint64
	txna ApplicationArgs 2
	btoi

	// partnerChannel: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// mbr: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==
	assert

	// execute cardFundCreate(pay,address,uint64)address
	callsub cardFundCreate
	concat
	log
	int 1
	return

// cardFundCreate(mbr: PayTxn, partnerChannel: Address, asset: AssetID): Address
//
// Create account. This generates a brand new account and funds the minimum balance requirement
// @param mbr Payment transaction of minimum balance requirement
// @param partnerChannel Funding Channel name
// @param asset Asset to opt-in to. 0 = No asset opt-in
// @returns Newly generated account used by their card
cardFundCreate:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 2

	// src/Immersve.algo.ts:500
	// assert(this.partner_channels(partnerChannel).exists, 'PARTNER_CHANNEL_NOT_FOUND')
	byte 0x7063 // "pc"
	frame_dig -2 // partnerChannel: Address
	concat
	box_len
	swap
	pop

	// PARTNER_CHANNEL_NOT_FOUND
	assert

	// src/Immersve.algo.ts:502
	// cardFundData: CardFundData = {
	//             partnerChannel: partnerChannel,
	//             owner: this.txn.sender,
	//             address: globals.zeroAddress,
	//             nonce: 0,
	//         }
	frame_dig -2 // partnerChannel: Address
	txn Sender
	concat
	global ZeroAddress
	concat
	byte 0x0000000000000000
	concat
	frame_bury 0 // cardFundData: CardFundData

	// src/Immersve.algo.ts:509
	// verifyPayTxn(mbr, {
	//             receiver: this.app.address,
	//             amount: this.getCardFundMbr(asset),
	//         })
	// verify receiver
	frame_dig -1 // mbr: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==
	assert

	// verify amount
	frame_dig -1 // mbr: PayTxn
	gtxns Amount
	frame_dig -3 // asset: AssetID
	callsub getCardFundMbr
	==
	assert

	// src/Immersve.algo.ts:515
	// cardFundAddr = sendMethodCall<typeof ControlledAddress.prototype.new>({
	//             onCompletion: OnCompletion.DeleteApplication,
	//             approvalProgram: ControlledAddress.approvalProgram(),
	//             clearStateProgram: ControlledAddress.clearProgram(),
	//         })
	itxn_begin
	int appl
	itxn_field TypeEnum
	method "new()address"
	itxn_field ApplicationArgs

	// src/Immersve.algo.ts:516
	// onCompletion: OnCompletion.DeleteApplication
	int 5 // DeleteApplication
	itxn_field OnCompletion

	// src/Immersve.algo.ts:517
	// approvalProgram: ControlledAddress.approvalProgram()
	byte b64 CiACAQAxGBSBBgsxGQiNDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJwCABBUffHWIAARQsCJDigABsSKyEDIKsgcjsggyDrIgI7IBszIKiYAEVh0v6jYaAI4B/80A
	itxn_field ApprovalProgram

	// src/Immersve.algo.ts:518
	// clearStateProgram: ControlledAddress.clearProgram()
	byte b64 Cg==
	itxn_field ClearStateProgram

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	int 1
	-
	itxnas Logs
	extract 4 0
	frame_bury 1 // cardFundAddr: address

	// src/Immersve.algo.ts:522
	// cardFundData.address = cardFundAddr
	frame_dig 0 // cardFundData: CardFundData
	int 64 // headOffset
	frame_dig 1 // cardFundAddr: address
	replace3
	frame_bury 0 // cardFundData: CardFundData

	// src/Immersve.algo.ts:525
	// assetMbr = asset ? globals.assetOptInMinBalance : 0
	frame_dig -3 // asset: AssetID
	bz *ternary7_false
	global AssetOptInMinBalance
	b *ternary7_end

*ternary7_false:
	int 0

*ternary7_end:
	frame_bury 2 // assetMbr: uint64

	// src/Immersve.algo.ts:526
	// sendPayment({
	//             receiver: cardFundAddr,
	//             amount: globals.minBalance + assetMbr,
	//         })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// src/Immersve.algo.ts:527
	// receiver: cardFundAddr
	frame_dig 1 // cardFundAddr: address
	itxn_field Receiver

	// src/Immersve.algo.ts:528
	// amount: globals.minBalance + assetMbr
	global MinBalance
	frame_dig 2 // assetMbr: uint64
	+
	itxn_field Amount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// *if0_condition
	// src/Immersve.algo.ts:532
	// asset
	frame_dig -3 // asset: AssetID
	bz *if0_end

	// *if0_consequent
	// src/Immersve.algo.ts:533
	// this.cardFundAssetOptIn(cardFundAddr, asset)
	frame_dig -3 // asset: AssetID
	frame_dig 1 // cardFundAddr: address
	callsub cardFundAssetOptIn

*if0_end:
	// src/Immersve.algo.ts:537
	// this.card_funds(cardFundAddr).value = cardFundData
	byte 0x6366 // "cf"
	frame_dig 1 // cardFundAddr: address
	concat
	frame_dig 0 // cardFundData: CardFundData
	box_put

	// src/Immersve.algo.ts:540
	// this.card_funds_active_count.value = this.card_funds_active_count.value + 1
	byte 0x63666163 // "cfac"
	dup
	app_global_get
	int 1
	+
	app_global_put

	// src/Immersve.algo.ts:542
	// this.CardFundCreated.log({
	//             cardFundOwner: this.txn.sender,
	//             cardFund: cardFundAddr,
	//             partnerChannel: partnerChannel,
	//         })
	byte 0xb4895e47 // CardFundCreated(address,address,address)
	txn Sender
	frame_dig 1 // cardFundAddr: address
	concat
	frame_dig -2 // partnerChannel: Address
	concat
	concat
	log

	// src/Immersve.algo.ts:549
	// return cardFundAddr;
	frame_dig 1 // cardFundAddr: address

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// cardFundClose(address)void
*abi_route_cardFundClose:
	// cardFund: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute cardFundClose(address)void
	callsub cardFundClose
	int 1
	return

// cardFundClose(cardFund: Address): void
//
// Close account. This permanently removes the rekey and deletes the account from the ledger
// @param cardFund Address to close
cardFundClose:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// src/Immersve.algo.ts:557
	// assert(this.isOwner() || this.isCardFundOwner(cardFund), 'SENDER_NOT_ALLOWED')
	callsub isOwner
	dup
	bnz *skip_or0
	frame_dig -1 // cardFund: Address
	callsub isCardFundOwner
	||

*skip_or0:
	// SENDER_NOT_ALLOWED
	assert

	// src/Immersve.algo.ts:559
	// sendPayment({
	//             sender: cardFund,
	//             receiver: cardFund,
	//             amount: 0,
	//             closeRemainderTo: this.txn.sender,
	//         })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// src/Immersve.algo.ts:560
	// sender: cardFund
	frame_dig -1 // cardFund: Address
	itxn_field Sender

	// src/Immersve.algo.ts:561
	// receiver: cardFund
	frame_dig -1 // cardFund: Address
	itxn_field Receiver

	// src/Immersve.algo.ts:562
	// amount: 0
	int 0
	itxn_field Amount

	// src/Immersve.algo.ts:563
	// closeRemainderTo: this.txn.sender
	txn Sender
	itxn_field CloseRemainderTo

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/Immersve.algo.ts:566
	// cardFundSize = this.card_funds(cardFund).size
	byte 0x6366 // "cf"
	frame_dig -1 // cardFund: Address
	concat
	box_len
	assert
	frame_bury 0 // cardFundSize: uint64

	// src/Immersve.algo.ts:567
	// boxCost = 2500 + 400 * (1 + 32 + cardFundSize)
	int 2500
	int 400
	int 33
	frame_dig 0 // cardFundSize: uint64
	+
	*
	+
	frame_bury 1 // boxCost: uint64

	// src/Immersve.algo.ts:569
	// sendPayment({
	//             receiver: this.txn.sender,
	//             amount: boxCost,
	//         })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// src/Immersve.algo.ts:570
	// receiver: this.txn.sender
	txn Sender
	itxn_field Receiver

	// src/Immersve.algo.ts:571
	// amount: boxCost
	frame_dig 1 // boxCost: uint64
	itxn_field Amount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/Immersve.algo.ts:575
	// this.card_funds(cardFund).delete()
	byte 0x6366 // "cf"
	frame_dig -1 // cardFund: Address
	concat
	box_del

	// src/Immersve.algo.ts:578
	// this.card_funds_active_count.value = this.card_funds_active_count.value - 1
	byte 0x63666163 // "cfac"
	dup
	app_global_get
	int 1
	-
	app_global_put
	retsub

// cardFundRecover(address,address)void
*abi_route_cardFundRecover:
	// newCardFundHolder: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// cardFund: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute cardFundRecover(address,address)void
	callsub cardFundRecover
	int 1
	return

// cardFundRecover(cardFund: Address, newCardFundHolder: Address): void
//
// Recovers funds from an old card and transfers them to a new card.
// Only the owner of the contract can perform this operation.
//
// @param cardFund - The card fund to recover.
// @param newCardFundHolder - The address of the new card holder.
cardFundRecover:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/Immersve.algo.ts:589
	// this.onlyOwner()
	callsub onlyOwner

	// src/Immersve.algo.ts:592
	// oldCardFundHolder = this.card_funds(cardFund).value.owner
	int 32 // headOffset
	int 32
	byte 0x6366 // "cf"
	frame_dig -1 // cardFund: Address
	concat
	cover 2
	box_extract
	frame_bury 0 // oldCardFundHolder: address

	// src/Immersve.algo.ts:593
	// this.card_funds(cardFund).value.owner = newCardFundHolder
	int 32 // headOffset
	frame_dig -2 // newCardFundHolder: Address
	byte 0x6366 // "cf"
	frame_dig -1 // cardFund: Address
	concat
	cover 2
	box_replace
	retsub

// getAssetAllowlistMbr()uint64
*abi_route_getAssetAllowlistMbr:
	// The ABI return prefix
	byte 0x151f7c75

	// execute getAssetAllowlistMbr()uint64
	callsub getAssetAllowlistMbr
	itob
	concat
	log
	int 1
	return

// getAssetAllowlistMbr(): uint64
//
// Retrieves the minimum balance requirement for adding an asset to the allowlist.
// @returns Minimum balance requirement for adding an asset to the allowlist
getAssetAllowlistMbr:
	proto 0 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/Immersve.algo.ts:604
	// ASSET_SETTLEMENT_ADDRESS_COST = 2500 + 400 * (2 + 8 + 32)
	int 19300
	frame_bury 0 // ASSET_SETTLEMENT_ADDRESS_COST: uint64

	// src/Immersve.algo.ts:605
	// return globals.assetOptInMinBalance + ASSET_SETTLEMENT_ADDRESS_COST;
	global AssetOptInMinBalance
	frame_dig 0 // ASSET_SETTLEMENT_ADDRESS_COST: uint64
	+

	// set the subroutine return value
	frame_bury 0
	retsub

// assetAllowlistAdd(pay,uint64,address)void
*abi_route_assetAllowlistAdd:
	// settlementAddress: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// asset: uint64
	txna ApplicationArgs 1
	btoi

	// mbr: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==
	assert

	// execute assetAllowlistAdd(pay,uint64,address)void
	callsub assetAllowlistAdd
	int 1
	return

// assetAllowlistAdd(mbr: PayTxn, asset: AssetID, settlementAddress: Address): void
//
// Allows the master contract to flag intent of accepting an asset.
//
// @param mbr Payment transaction of minimum balance requirement.
// @param asset The AssetID of the asset being transferred.
assetAllowlistAdd:
	proto 3 0

	// src/Immersve.algo.ts:615
	// this.onlyOwner()
	callsub onlyOwner

	// src/Immersve.algo.ts:617
	// verifyPayTxn(mbr, {
	//             receiver: this.app.address,
	//             amount: this.getAssetAllowlistMbr(),
	//         })
	// verify receiver
	frame_dig -1 // mbr: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==
	assert

	// verify amount
	frame_dig -1 // mbr: PayTxn
	gtxns Amount
	callsub getAssetAllowlistMbr
	==
	assert

	// src/Immersve.algo.ts:622
	// sendAssetTransfer({
	//             sender: this.app.address,
	//             assetReceiver: this.app.address,
	//             xferAsset: asset,
	//             assetAmount: 0,
	//         })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// src/Immersve.algo.ts:623
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// src/Immersve.algo.ts:624
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// src/Immersve.algo.ts:625
	// xferAsset: asset
	frame_dig -2 // asset: AssetID
	itxn_field XferAsset

	// src/Immersve.algo.ts:626
	// assetAmount: 0
	int 0
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/Immersve.algo.ts:629
	// this.AssetAllowlistAdded.log({ asset: asset })
	byte 0x2636bc7e // AssetAllowlistAdded(uint64)
	frame_dig -2 // asset: AssetID
	itob
	concat
	log

	// src/Immersve.algo.ts:631
	// this.updateSettlementAddress(asset, settlementAddress)
	frame_dig -3 // settlementAddress: Address
	frame_dig -2 // asset: AssetID
	callsub updateSettlementAddress
	retsub

// assetAllowlistRemove(uint64)void
*abi_route_assetAllowlistRemove:
	// asset: uint64
	txna ApplicationArgs 1
	btoi

	// execute assetAllowlistRemove(uint64)void
	callsub assetAllowlistRemove
	int 1
	return

// assetAllowlistRemove(asset: AssetID): void
//
// Allows the master contract to reject accepting an asset.
//
// @param asset - The AssetID of the asset being transferred.
assetAllowlistRemove:
	proto 1 0

	// src/Immersve.algo.ts:640
	// this.onlyOwner()
	callsub onlyOwner

	// src/Immersve.algo.ts:643
	// sendAssetTransfer({
	//             sender: this.app.address,
	//             assetReceiver: this.app.address,
	//             assetCloseTo: this.app.address,
	//             xferAsset: asset,
	//             assetAmount: 0,
	//         })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// src/Immersve.algo.ts:644
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// src/Immersve.algo.ts:645
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// src/Immersve.algo.ts:646
	// assetCloseTo: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetCloseTo

	// src/Immersve.algo.ts:647
	// xferAsset: asset
	frame_dig -1 // asset: AssetID
	itxn_field XferAsset

	// src/Immersve.algo.ts:648
	// assetAmount: 0
	int 0
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/Immersve.algo.ts:652
	// this.settlement_address(asset).delete()
	byte 0x7361 // "sa"
	frame_dig -1 // asset: AssetID
	itob
	concat
	box_del

	// src/Immersve.algo.ts:654
	// sendPayment({
	//             receiver: this.txn.sender,
	//             amount: this.getAssetAllowlistMbr(),
	//         })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// src/Immersve.algo.ts:655
	// receiver: this.txn.sender
	txn Sender
	itxn_field Receiver

	// src/Immersve.algo.ts:656
	// amount: this.getAssetAllowlistMbr()
	callsub getAssetAllowlistMbr
	itxn_field Amount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/Immersve.algo.ts:659
	// this.AssetAllowlistRemoved.log({ asset: asset })
	byte 0x065c0374 // AssetAllowlistRemoved(uint64)
	frame_dig -1 // asset: AssetID
	itob
	concat
	log
	retsub

// cardFundDebit(address,uint64,uint64,uint64)void
*abi_route_cardFundDebit:
	// nonce: uint64
	txna ApplicationArgs 4
	btoi

	// amount: uint64
	txna ApplicationArgs 3
	btoi

	// asset: uint64
	txna ApplicationArgs 2
	btoi

	// cardFund: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute cardFundDebit(address,uint64,uint64,uint64)void
	callsub cardFundDebit
	int 1
	return

// cardFundDebit(cardFund: Address, asset: AssetID, amount: uint64, nonce: uint64): void
//
// Debits the specified amount of the given asset from the card account.
// Only the owner of the contract can perform this operation.
//
// @param cardFund The card fund from which the asset will be debited.
// @param asset The asset to be debited.
// @param amount The amount of the asset to be debited.
cardFundDebit:
	proto 4 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/Immersve.algo.ts:671
	// this.whenNotPaused()
	callsub whenNotPaused

	// src/Immersve.algo.ts:672
	// this.onlyOwner()
	callsub onlyOwner

	// src/Immersve.algo.ts:675
	// nextNonce = this.card_funds(cardFund).value.nonce
	int 96 // headOffset
	int 8
	byte 0x6366 // "cf"
	frame_dig -1 // cardFund: Address
	concat
	cover 2
	box_extract
	btoi
	frame_bury 0 // nextNonce: uint64

	// src/Immersve.algo.ts:676
	// assert(nextNonce === nonce, 'NONCE_INVALID')
	frame_dig 0 // nextNonce: uint64
	frame_dig -4 // nonce: uint64
	==

	// NONCE_INVALID
	assert

	// src/Immersve.algo.ts:678
	// sendAssetTransfer({
	//             sender: cardFund,
	//             assetReceiver: this.app.address,
	//             xferAsset: asset,
	//             assetAmount: amount,
	//         })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// src/Immersve.algo.ts:679
	// sender: cardFund
	frame_dig -1 // cardFund: Address
	itxn_field Sender

	// src/Immersve.algo.ts:680
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// src/Immersve.algo.ts:681
	// xferAsset: asset
	frame_dig -2 // asset: AssetID
	itxn_field XferAsset

	// src/Immersve.algo.ts:682
	// assetAmount: amount
	frame_dig -3 // amount: uint64
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/Immersve.algo.ts:685
	// this.Debit.log({
	//             card: cardFund,
	//             asset: asset,
	//             amount: amount,
	//             nonce: nonce,
	//         })
	byte 0x5c5b9134 // Debit(address,uint64,uint64,uint64)
	frame_dig -1 // cardFund: Address
	frame_dig -2 // asset: AssetID
	itob
	concat
	frame_dig -3 // amount: uint64
	itob
	concat
	frame_dig -4 // nonce: uint64
	itob
	concat
	concat
	log

	// src/Immersve.algo.ts:693
	// this.card_funds(cardFund).value.nonce = nextNonce + 1
	int 96 // headOffset
	frame_dig 0 // nextNonce: uint64
	int 1
	+
	itob
	byte 0x6366 // "cf"
	frame_dig -1 // cardFund: Address
	concat
	cover 2
	box_replace
	retsub

// getRefundAddress()address
*abi_route_getRefundAddress:
	// The ABI return prefix
	byte 0x151f7c75

	// execute getRefundAddress()address
	callsub getRefundAddress
	concat
	log
	int 1
	return

// getRefundAddress(): Address
//
// Retrieves the refund address.
//
// @returns The refund address.
getRefundAddress:
	proto 0 1

	// src/Immersve.algo.ts:703
	// return this.refund_address.value;
	byte 0x7261 // "ra"
	app_global_get
	retsub

// setRefundAddress(address)void
*abi_route_setRefundAddress:
	// newRefundAddress: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute setRefundAddress(address)void
	callsub setRefundAddress
	int 1
	return

// setRefundAddress(newRefundAddress: Address): void
//
// Sets the refund address.
// Only the owner of the contract can call this method.
//
// @param newRefundAddress The new refund address to be set.
setRefundAddress:
	proto 1 0

	// src/Immersve.algo.ts:713
	// this.onlyOwner()
	callsub onlyOwner

	// src/Immersve.algo.ts:715
	// this.refund_address.value = newRefundAddress
	byte 0x7261 // "ra"
	frame_dig -1 // newRefundAddress: Address
	app_global_put
	retsub

// cardFundRefund(address,uint64,uint64,uint64)void
*abi_route_cardFundRefund:
	// nonce: uint64
	txna ApplicationArgs 4
	btoi

	// amount: uint64
	txna ApplicationArgs 3
	btoi

	// asset: uint64
	txna ApplicationArgs 2
	btoi

	// cardFund: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute cardFundRefund(address,uint64,uint64,uint64)void
	callsub cardFundRefund
	int 1
	return

// cardFundRefund(cardFund: Address, asset: AssetID, amount: uint64, nonce: uint64): void
//
// Refunds a specified amount of an asset to a card account.
// Only the owner of the contract can perform this operation.
//
// @param cardFund - The card account to refund the asset to.
// @param asset - The asset to refund.
// @param amount - The amount of the asset to refund.
cardFundRefund:
	proto 4 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/Immersve.algo.ts:727
	// this.whenNotPaused()
	callsub whenNotPaused

	// src/Immersve.algo.ts:729
	// assert(this.txn.sender === this.refund_address.value, 'SENDER_NOT_ALLOWED')
	txn Sender
	byte 0x7261 // "ra"
	app_global_get
	==

	// SENDER_NOT_ALLOWED
	assert

	// src/Immersve.algo.ts:732
	// nextNonce = this.card_funds(cardFund).value.nonce
	int 96 // headOffset
	int 8
	byte 0x6366 // "cf"
	frame_dig -1 // cardFund: Address
	concat
	cover 2
	box_extract
	btoi
	frame_bury 0 // nextNonce: uint64

	// src/Immersve.algo.ts:733
	// assert(nextNonce === nonce, 'NONCE_INVALID')
	frame_dig 0 // nextNonce: uint64
	frame_dig -4 // nonce: uint64
	==

	// NONCE_INVALID
	assert

	// src/Immersve.algo.ts:735
	// sendAssetTransfer({
	//             sender: this.app.address,
	//             assetReceiver: cardFund,
	//             xferAsset: asset,
	//             assetAmount: amount,
	//         })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// src/Immersve.algo.ts:736
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// src/Immersve.algo.ts:737
	// assetReceiver: cardFund
	frame_dig -1 // cardFund: Address
	itxn_field AssetReceiver

	// src/Immersve.algo.ts:738
	// xferAsset: asset
	frame_dig -2 // asset: AssetID
	itxn_field XferAsset

	// src/Immersve.algo.ts:739
	// assetAmount: amount
	frame_dig -3 // amount: uint64
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/Immersve.algo.ts:742
	// this.Refund.log({
	//             card: cardFund,
	//             asset: asset,
	//             amount: amount,
	//             nonce: nonce,
	//         })
	byte 0xe37aae5c // Refund(address,uint64,uint64,uint64)
	frame_dig -1 // cardFund: Address
	frame_dig -2 // asset: AssetID
	itob
	concat
	frame_dig -3 // amount: uint64
	itob
	concat
	frame_dig -4 // nonce: uint64
	itob
	concat
	concat
	log

	// src/Immersve.algo.ts:750
	// this.card_funds(cardFund).value.nonce = nextNonce + 1
	int 96 // headOffset
	frame_dig 0 // nextNonce: uint64
	int 1
	+
	itob
	byte 0x6366 // "cf"
	frame_dig -1 // cardFund: Address
	concat
	cover 2
	box_replace
	retsub

// getNextSettlementNonce()uint64
*abi_route_getNextSettlementNonce:
	// The ABI return prefix
	byte 0x151f7c75

	// execute getNextSettlementNonce()uint64
	callsub getNextSettlementNonce
	itob
	concat
	log
	int 1
	return

// getNextSettlementNonce(): uint64
//
// Retrieves the next available nonce for settlements.
//
// @returns The settlement nonce.
getNextSettlementNonce:
	proto 0 1

	// src/Immersve.algo.ts:760
	// return this.settlement_nonce.value;
	byte 0x736e // "sn"
	app_global_get
	retsub

// getNextCardFundNonce(address)uint64
*abi_route_getNextCardFundNonce:
	// The ABI return prefix
	byte 0x151f7c75

	// cardFund: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute getNextCardFundNonce(address)uint64
	callsub getNextCardFundNonce
	itob
	concat
	log
	int 1
	return

// getNextCardFundNonce(cardFund: Address): uint64
//
// Retrieves the next available nonce for the card fund.
//
// @param cardFund The card fund address.
// @returns The nonce for the card fund.
getNextCardFundNonce:
	proto 1 1

	// src/Immersve.algo.ts:771
	// return this.card_funds(cardFund).value.nonce;
	int 96 // headOffset
	int 8
	byte 0x6366 // "cf"
	frame_dig -1 // cardFund: Address
	concat
	cover 2
	box_extract
	btoi
	retsub

// getCardFundData(address)(address,address,address,uint64)
*abi_route_getCardFundData:
	// The ABI return prefix
	byte 0x151f7c75

	// cardFund: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute getCardFundData(address)(address,address,address,uint64)
	callsub getCardFundData
	concat
	log
	int 1
	return

// getCardFundData(cardFund: Address): CardFundData
//
// Retrieves the card fund data for a given card fund address.
//
// @param cardFund The address of the card fund.
// @returns The card fund data.
getCardFundData:
	proto 1 1

	// src/Immersve.algo.ts:782
	// return this.card_funds(cardFund).value;
	byte 0x6366 // "cf"
	frame_dig -1 // cardFund: Address
	concat
	box_get
	assert
	retsub

// getSettlementAddress(uint64)address
*abi_route_getSettlementAddress:
	// The ABI return prefix
	byte 0x151f7c75

	// asset: uint64
	txna ApplicationArgs 1
	btoi

	// execute getSettlementAddress(uint64)address
	callsub getSettlementAddress
	concat
	log
	int 1
	return

// getSettlementAddress(asset: AssetID): Address
//
// Retrieves the settlement address for the specified asset.
//
// @param asset The ID of the asset.
// @returns The settlement address for the asset.
getSettlementAddress:
	proto 1 1

	// src/Immersve.algo.ts:793
	// return this.settlement_address(asset).value;
	byte 0x7361 // "sa"
	frame_dig -1 // asset: AssetID
	itob
	concat
	box_get
	assert
	retsub

// setSettlementAddress(uint64,address)void
*abi_route_setSettlementAddress:
	// newSettlementAddress: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// settlementAsset: uint64
	txna ApplicationArgs 1
	btoi

	// execute setSettlementAddress(uint64,address)void
	callsub setSettlementAddress
	int 1
	return

// setSettlementAddress(settlementAsset: AssetID, newSettlementAddress: Address): void
//
// Sets the settlement address for a given settlement asset.
// Only the owner of the contract can call this method.
//
// @param settlementAsset The ID of the settlement asset.
// @param newSettlementAddress The new settlement address to be set.
setSettlementAddress:
	proto 2 0

	// src/Immersve.algo.ts:804
	// this.onlyOwner()
	callsub onlyOwner

	// src/Immersve.algo.ts:806
	// this.updateSettlementAddress(settlementAsset, newSettlementAddress)
	frame_dig -2 // newSettlementAddress: Address
	frame_dig -1 // settlementAsset: AssetID
	callsub updateSettlementAddress
	retsub

// settle(uint64,uint64,uint64)void
*abi_route_settle:
	// nonce: uint64
	txna ApplicationArgs 3
	btoi

	// amount: uint64
	txna ApplicationArgs 2
	btoi

	// asset: uint64
	txna ApplicationArgs 1
	btoi

	// execute settle(uint64,uint64,uint64)void
	callsub settle
	int 1
	return

// settle(asset: AssetID, amount: uint64, nonce: uint64): void
//
// Settles a payment by transferring an asset to the specified recipient.
// Only the owner of the contract can call this function.
//
// @param asset The asset to be transferred.
// @param amount The amount of the asset to be transferred.
// @param nonce The nonce to prevent duplicate settlements.
settle:
	proto 3 0

	// src/Immersve.algo.ts:818
	// this.whenNotPaused()
	callsub whenNotPaused

	// src/Immersve.algo.ts:819
	// this.onlyOwner()
	callsub onlyOwner

	// src/Immersve.algo.ts:822
	// assert(this.settlement_nonce.value === nonce, 'NONCE_INVALID')
	byte 0x736e // "sn"
	app_global_get
	frame_dig -3 // nonce: uint64
	==

	// NONCE_INVALID
	assert

	// src/Immersve.algo.ts:824
	// sendAssetTransfer({
	//             sender: this.app.address,
	//             assetReceiver: this.settlement_address(asset).value,
	//             xferAsset: asset,
	//             assetAmount: amount,
	//         })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// src/Immersve.algo.ts:825
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// src/Immersve.algo.ts:826
	// assetReceiver: this.settlement_address(asset).value
	byte 0x7361 // "sa"
	frame_dig -1 // asset: AssetID
	itob
	concat
	box_get
	assert
	itxn_field AssetReceiver

	// src/Immersve.algo.ts:827
	// xferAsset: asset
	frame_dig -1 // asset: AssetID
	itxn_field XferAsset

	// src/Immersve.algo.ts:828
	// assetAmount: amount
	frame_dig -2 // amount: uint64
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/Immersve.algo.ts:831
	// this.Settlement.log({
	//             recipient: this.settlement_address(asset).value,
	//             asset: asset,
	//             amount: amount,
	//             nonce: nonce,
	//         })
	byte 0x558046ec // Settlement(address,uint64,uint64,uint64)
	byte 0x7361 // "sa"
	frame_dig -1 // asset: AssetID
	itob
	concat
	box_get
	assert
	frame_dig -1 // asset: AssetID
	itob
	concat
	frame_dig -2 // amount: uint64
	itob
	concat
	frame_dig -3 // nonce: uint64
	itob
	concat
	concat
	log

	// src/Immersve.algo.ts:839
	// this.settlement_nonce.value = this.settlement_nonce.value + 1
	byte 0x736e // "sn"
	dup
	app_global_get
	int 1
	+
	app_global_put
	retsub

// getCardFundAssetMbr()uint64
*abi_route_getCardFundAssetMbr:
	// The ABI return prefix
	byte 0x151f7c75

	// execute getCardFundAssetMbr()uint64
	callsub getCardFundAssetMbr
	itob
	concat
	log
	int 1
	return

// getCardFundAssetMbr(): uint64
//
// Retrieves the minimum balance requirement for adding an asset to the card fund.
// @returns The minimum balance requirement for adding an asset to the card fund.
getCardFundAssetMbr:
	proto 0 1

	// src/Immersve.algo.ts:847
	// return globals.assetOptInMinBalance;
	global AssetOptInMinBalance
	retsub

// cardFundEnableAsset(pay,address,uint64)void
*abi_route_cardFundEnableAsset:
	// asset: uint64
	txna ApplicationArgs 2
	btoi

	// cardFund: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// mbr: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==
	assert

	// execute cardFundEnableAsset(pay,address,uint64)void
	callsub cardFundEnableAsset
	int 1
	return

// cardFundEnableAsset(mbr: PayTxn, cardFund: Address, asset: AssetID): void
//
// Allows the depositor (or owner) to OptIn to an asset, increasing the minimum balance requirement of the account
//
// @param cardFund Address to add asset to
// @param asset Asset to add
cardFundEnableAsset:
	proto 3 0

	// src/Immersve.algo.ts:858
	// assert(this.isOwner() || this.isCardFundOwner(cardFund), 'SENDER_NOT_ALLOWED')
	callsub isOwner
	dup
	bnz *skip_or1
	frame_dig -2 // cardFund: Address
	callsub isCardFundOwner
	||

*skip_or1:
	// SENDER_NOT_ALLOWED
	assert

	// src/Immersve.algo.ts:860
	// verifyPayTxn(mbr, {
	//             receiver: this.app.address,
	//             amount: this.getCardFundAssetMbr(),
	//         })
	// verify receiver
	frame_dig -1 // mbr: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==
	assert

	// verify amount
	frame_dig -1 // mbr: PayTxn
	gtxns Amount
	callsub getCardFundAssetMbr
	==
	assert

	// src/Immersve.algo.ts:865
	// sendPayment({
	//             receiver: cardFund,
	//             amount: this.getCardFundAssetMbr(),
	//         })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// src/Immersve.algo.ts:866
	// receiver: cardFund
	frame_dig -2 // cardFund: Address
	itxn_field Receiver

	// src/Immersve.algo.ts:867
	// amount: this.getCardFundAssetMbr()
	callsub getCardFundAssetMbr
	itxn_field Amount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/Immersve.algo.ts:870
	// this.cardFundAssetOptIn(cardFund, asset)
	frame_dig -3 // asset: AssetID
	frame_dig -2 // cardFund: Address
	callsub cardFundAssetOptIn
	retsub

// cardFundDisableAsset(address,uint64)void
*abi_route_cardFundDisableAsset:
	// asset: uint64
	txna ApplicationArgs 2
	btoi

	// cardFund: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute cardFundDisableAsset(address,uint64)void
	callsub cardFundDisableAsset
	int 1
	return

// cardFundDisableAsset(cardFund: Address, asset: AssetID): void
//
// Allows the depositor (or owner) to CloseOut of an asset, reducing the minimum balance requirement of the account
//
// @param cardFund - The address of the card.
// @param asset - The ID of the asset to be removed.
cardFundDisableAsset:
	proto 2 0

	// src/Immersve.algo.ts:880
	// assert(this.isOwner() || this.isCardFundOwner(cardFund), 'SENDER_NOT_ALLOWED')
	callsub isOwner
	dup
	bnz *skip_or2
	frame_dig -1 // cardFund: Address
	callsub isCardFundOwner
	||

*skip_or2:
	// SENDER_NOT_ALLOWED
	assert

	// src/Immersve.algo.ts:882
	// this.cardFundAssetCloseOut(cardFund, asset)
	frame_dig -2 // asset: AssetID
	frame_dig -1 // cardFund: Address
	callsub cardFundAssetCloseOut
	retsub

// cardFundWithdrawalRequest(address,address,uint64,uint64)byte[32]
*abi_route_cardFundWithdrawalRequest:
	// The ABI return prefix
	byte 0x151f7c75

	// amount: uint64
	txna ApplicationArgs 4
	btoi

	// asset: uint64
	txna ApplicationArgs 3
	btoi

	// recipient: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// cardFund: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute cardFundWithdrawalRequest(address,address,uint64,uint64)byte[32]
	callsub cardFundWithdrawalRequest
	concat
	log
	int 1
	return

// cardFundWithdrawalRequest(cardFund: Address, recipient: Address, asset: AssetID, amount: uint64): bytes32
//
// Allows the Card Holder (or contract owner) to send an amount of assets from the account
// @param cardFund Address to withdraw from
// @param asset Asset to withdraw
// @param amount Amount to withdraw
// @returns Withdrawal hash used for completing or cancelling the withdrawal
cardFundWithdrawalRequest:
	proto 4 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// src/Immersve.algo.ts:895
	// assert(this.isOwner() || this.isCardFundOwner(cardFund), 'SENDER_NOT_ALLOWED')
	callsub isOwner
	dup
	bnz *skip_or3
	frame_dig -1 // cardFund: Address
	callsub isCardFundOwner
	||

*skip_or3:
	// SENDER_NOT_ALLOWED
	assert

	// src/Immersve.algo.ts:897
	// withdrawal: WithdrawalRequest = {
	//             cardFund: cardFund,
	//             recipient: recipient,
	//             asset: asset,
	//             amount: amount,
	//             timestamp: globals.latestTimestamp + this.withdrawal_wait_time.value,
	//             nonce: this.withdrawal_nonce(this.txn.sender).value,
	//         }
	frame_dig -1 // cardFund: Address
	frame_dig -2 // recipient: Address
	concat
	frame_dig -3 // asset: AssetID
	itob
	concat
	frame_dig -4 // amount: uint64
	itob
	concat
	global LatestTimestamp
	byte 0x777774 // "wwt"
	app_global_get
	+
	itob
	concat
	txn Sender
	byte 0x776e // "wn"
	app_local_get
	itob
	concat
	frame_bury 0 // withdrawal: WithdrawalRequest

	// src/Immersve.algo.ts:905
	// this.withdrawal_nonce(this.txn.sender).value = this.withdrawal_nonce(this.txn.sender).value + 1
	txn Sender
	byte 0x776e // "wn"
	txn Sender
	byte 0x776e // "wn"
	app_local_get
	int 1
	+
	app_local_put

	// src/Immersve.algo.ts:906
	// withdrawal_hash = sha256(rawBytes(withdrawal))
	frame_dig 0 // withdrawal: WithdrawalRequest
	sha256
	frame_bury 1 // withdrawal_hash: byte[32]

	// src/Immersve.algo.ts:908
	// this.withdrawals(this.txn.sender, withdrawal_hash).value = withdrawal
	txn Sender
	frame_dig 1 // withdrawal_hash: byte[32]
	frame_dig 0 // withdrawal: WithdrawalRequest
	app_local_put

	// src/Immersve.algo.ts:910
	// this.WithdrawalRequest.log({
	//             cardFund: withdrawal.cardFund,
	//             recipient: withdrawal.recipient,
	//             asset: withdrawal.asset,
	//             amount: withdrawal.amount,
	//             timestamp: withdrawal.timestamp,
	//             nonce: withdrawal.nonce,
	//         })
	byte 0xd85f620a // WithdrawalRequest(address,address,uint64,uint64,uint64,uint64)
	frame_dig 0 // withdrawal: WithdrawalRequest
	extract 0 32
	frame_dig 0 // withdrawal: WithdrawalRequest
	extract 32 32
	concat
	frame_dig 0 // withdrawal: WithdrawalRequest
	extract 64 8
	btoi
	itob
	concat
	frame_dig 0 // withdrawal: WithdrawalRequest
	extract 72 8
	btoi
	itob
	concat
	frame_dig 0 // withdrawal: WithdrawalRequest
	extract 80 8
	btoi
	itob
	concat
	frame_dig 0 // withdrawal: WithdrawalRequest
	extract 88 8
	btoi
	itob
	concat
	concat
	log

	// src/Immersve.algo.ts:919
	// return withdrawal_hash;
	frame_dig 1 // withdrawal_hash: byte[32]

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// cardFundWithdrawalCancel(address,byte[32])void
*abi_route_cardFundWithdrawalCancel:
	// withdrawal_hash: byte[32]
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// cardFund: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute cardFundWithdrawalCancel(address,byte[32])void
	callsub cardFundWithdrawalCancel
	int 1
	return

// cardFundWithdrawalCancel(cardFund: Address, withdrawal_hash: bytes32): void
//
// Allows the Card Holder (or contract owner) to cancel a withdrawal request
// @param cardFund Address to withdraw from
// @param withdrawal_hash Hash of the withdrawal request
cardFundWithdrawalCancel:
	proto 2 0

	// src/Immersve.algo.ts:928
	// assert(this.isOwner() || this.isCardFundOwner(cardFund), 'SENDER_NOT_ALLOWED')
	callsub isOwner
	dup
	bnz *skip_or4
	frame_dig -1 // cardFund: Address
	callsub isCardFundOwner
	||

*skip_or4:
	// SENDER_NOT_ALLOWED
	assert

	// src/Immersve.algo.ts:930
	// this.withdrawals(this.txn.sender, withdrawal_hash).delete()
	txn Sender
	frame_dig -2 // withdrawal_hash: bytes32
	app_local_del
	retsub

// cardFundWithdraw(address,byte[32])void
*abi_route_cardFundWithdraw:
	// withdrawal_hash: byte[32]
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// cardFund: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute cardFundWithdraw(address,byte[32])void
	callsub cardFundWithdraw
	int 1
	return

// cardFundWithdraw(cardFund: Address, withdrawal_hash: bytes32): void
//
// Allows the Card Holder to send an amount of assets from the account
// @param cardFund Address to withdraw from
// @param withdrawal_hash Hash of the withdrawal request
cardFundWithdraw:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// src/Immersve.algo.ts:941
	// assert(this.isOwner() || this.isCardFundOwner(cardFund), 'SENDER_NOT_ALLOWED')
	callsub isOwner
	dup
	bnz *skip_or5
	frame_dig -1 // cardFund: Address
	callsub isCardFundOwner
	||

*skip_or5:
	// SENDER_NOT_ALLOWED
	assert

	// src/Immersve.algo.ts:943
	// withdrawal = this.withdrawals(this.txn.sender, withdrawal_hash).value
	frame_dig -2 // withdrawal_hash: bytes32
	frame_bury 0 // storage key//withdrawal

	// src/Immersve.algo.ts:943
	// withdrawal = this.withdrawals(this.txn.sender, withdrawal_hash).value
	txn Sender
	frame_bury 1 // storage account//withdrawal

	// src/Immersve.algo.ts:945
	// assert(globals.latestTimestamp >= withdrawal.timestamp || this.isOwner(), 'WITHDRAWAL_TIME_INVALID')
	global LatestTimestamp
	frame_dig 1 // storage account//withdrawal
	frame_dig 0 // storage key//withdrawal
	app_local_get
	extract 80 8
	btoi
	>=
	dup
	bnz *skip_or6
	callsub isOwner
	||

*skip_or6:
	// WITHDRAWAL_TIME_INVALID
	assert

	// src/Immersve.algo.ts:948
	// this.withdrawFunds(withdrawal)
	frame_dig 1 // storage account//withdrawal
	frame_dig 0 // storage key//withdrawal
	app_local_get
	callsub withdrawFunds

	// src/Immersve.algo.ts:951
	// this.withdrawals(this.txn.sender, withdrawal_hash).delete()
	txn Sender
	frame_dig -2 // withdrawal_hash: bytes32
	app_local_del
	retsub

// cardFundWithdrawEarly(address,byte[32],byte[64])void
*abi_route_cardFundWithdrawEarly:
	// early_withdrawal_sig: byte[64]
	txna ApplicationArgs 3
	dup
	len
	int 64
	==
	assert

	// withdrawal_hash: byte[32]
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// cardFund: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute cardFundWithdrawEarly(address,byte[32],byte[64])void
	callsub cardFundWithdrawEarly
	int 1
	return

// cardFundWithdrawEarly(cardFund: Address, withdrawal_hash: bytes32, early_withdrawal_sig: bytes64): void
//
// Withdraws funds before the withdrawal timestamp has lapsed, by using the early withdrawal signature provided by Immersve.
// @param cardFund - The address of the card.
// @param withdrawal_hash - The hash of the withdrawal.
// @param early_withdrawal_sig - The signature for early withdrawal.
cardFundWithdrawEarly:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// src/Immersve.algo.ts:961
	// assert(this.isCardFundOwner(cardFund), 'SENDER_NOT_ALLOWED')
	frame_dig -1 // cardFund: Address
	callsub isCardFundOwner

	// SENDER_NOT_ALLOWED
	assert

	// src/Immersve.algo.ts:963
	// withdrawal = this.withdrawals(this.txn.sender, withdrawal_hash).value
	frame_dig -2 // withdrawal_hash: bytes32
	frame_bury 0 // storage key//withdrawal

	// src/Immersve.algo.ts:963
	// withdrawal = this.withdrawals(this.txn.sender, withdrawal_hash).value
	txn Sender
	frame_bury 1 // storage account//withdrawal

	// *if1_condition
	// src/Immersve.algo.ts:966
	// globals.latestTimestamp < withdrawal.timestamp
	global LatestTimestamp
	frame_dig 1 // storage account//withdrawal
	frame_dig 0 // storage key//withdrawal
	app_local_get
	extract 80 8
	btoi
	<
	bz *if1_end

// *if1_consequent
*while_0:

*while_0_continue:
	// src/Immersve.algo.ts:969
	// globals.opcodeBudget < 2500
	global OpcodeBudget
	int 2500
	<
	bz *while_0_end

	// src/Immersve.algo.ts:970
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit
	b *while_0

*while_0_end:
	// src/Immersve.algo.ts:973
	// assert(
	//                 ed25519VerifyBare(withdrawal_hash, early_withdrawal_sig, this.early_withdrawal_pubkey.value),
	//                 'SIGNATURE_INVALID'
	//             )
	frame_dig -2 // withdrawal_hash: bytes32
	frame_dig -3 // early_withdrawal_sig: bytes64
	byte 0x6577706b // "ewpk"
	app_global_get
	ed25519verify_bare

	// SIGNATURE_INVALID
	assert

*if1_end:
	// src/Immersve.algo.ts:980
	// this.withdrawFunds(withdrawal)
	frame_dig 1 // storage account//withdrawal
	frame_dig 0 // storage key//withdrawal
	app_local_get
	callsub withdrawFunds

	// src/Immersve.algo.ts:983
	// this.withdrawals(this.txn.sender, withdrawal_hash).delete()
	txn Sender
	frame_dig -2 // withdrawal_hash: bytes32
	app_local_del
	retsub

*create_NoOp:
	method "deploy(address)address"
	txna ApplicationArgs 0
	match *abi_route_deploy
	err

*call_NoOp:
	method "owner()address"
	method "transferOwnership(address)void"
	method "pauser()address"
	method "pause()void"
	method "unpause()void"
	method "updatePauser(address)void"
	method "setWithdrawalTimeout(uint64)void"
	method "setEarlyWithdrawalPubkey(byte[32])void"
	method "getPartnerChannelMbr(string)uint64"
	method "partnerChannelCreate(pay,string)address"
	method "partnerChannelClose(address)void"
	method "getCardFundMbr(uint64)uint64"
	method "cardFundCreate(pay,address,uint64)address"
	method "cardFundClose(address)void"
	method "cardFundRecover(address,address)void"
	method "getAssetAllowlistMbr()uint64"
	method "assetAllowlistAdd(pay,uint64,address)void"
	method "assetAllowlistRemove(uint64)void"
	method "cardFundDebit(address,uint64,uint64,uint64)void"
	method "getRefundAddress()address"
	method "setRefundAddress(address)void"
	method "cardFundRefund(address,uint64,uint64,uint64)void"
	method "getNextSettlementNonce()uint64"
	method "getNextCardFundNonce(address)uint64"
	method "getCardFundData(address)(address,address,address,uint64)"
	method "getSettlementAddress(uint64)address"
	method "setSettlementAddress(uint64,address)void"
	method "settle(uint64,uint64,uint64)void"
	method "getCardFundAssetMbr()uint64"
	method "cardFundEnableAsset(pay,address,uint64)void"
	method "cardFundDisableAsset(address,uint64)void"
	method "cardFundWithdrawalRequest(address,address,uint64,uint64)byte[32]"
	method "cardFundWithdrawalCancel(address,byte[32])void"
	method "cardFundWithdraw(address,byte[32])void"
	method "cardFundWithdrawEarly(address,byte[32],byte[64])void"
	txna ApplicationArgs 0
	match *abi_route_owner *abi_route_transferOwnership *abi_route_pauser *abi_route_pause *abi_route_unpause *abi_route_updatePauser *abi_route_setWithdrawalTimeout *abi_route_setEarlyWithdrawalPubkey *abi_route_getPartnerChannelMbr *abi_route_partnerChannelCreate *abi_route_partnerChannelClose *abi_route_getCardFundMbr *abi_route_cardFundCreate *abi_route_cardFundClose *abi_route_cardFundRecover *abi_route_getAssetAllowlistMbr *abi_route_assetAllowlistAdd *abi_route_assetAllowlistRemove *abi_route_cardFundDebit *abi_route_getRefundAddress *abi_route_setRefundAddress *abi_route_cardFundRefund *abi_route_getNextSettlementNonce *abi_route_getNextCardFundNonce *abi_route_getCardFundData *abi_route_getSettlementAddress *abi_route_setSettlementAddress *abi_route_settle *abi_route_getCardFundAssetMbr *abi_route_cardFundEnableAsset *abi_route_cardFundDisableAsset *abi_route_cardFundWithdrawalRequest *abi_route_cardFundWithdrawalCancel *abi_route_cardFundWithdraw *abi_route_cardFundWithdrawEarly
	err

*call_OptIn:
	method "cardFundWithdrawalRequest(address,address,uint64,uint64)byte[32]"
	txna ApplicationArgs 0
	match *abi_route_cardFundWithdrawalRequest
	err

*call_CloseOut:
	method "cardFundWithdraw(address,byte[32])void"
	txna ApplicationArgs 0
	match *abi_route_cardFundWithdraw
	err

*call_UpdateApplication:
	method "update()void"
	txna ApplicationArgs 0
	match *abi_route_update
	err

*call_DeleteApplication:
	method "destroy()void"
	txna ApplicationArgs 0
	match *abi_route_destroy
	err

*process_static_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -1 // element
	concat
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub

*process_dynamic_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -2 // head offset
	concat
	frame_bury -4 // tuple head
	frame_dig -1 // element
	dup
	len
	frame_dig -2 // head offset
	btoi
	+
	itob
	extract 6 2
	frame_bury -2 // head offset
	frame_dig -3 // tuple tail
	swap
	concat
	frame_bury -3 // tuple tail
	frame_dig -4 // tuple head
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub