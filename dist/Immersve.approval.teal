#pragma version 10

// This TEAL was generated by TEALScript v0.82.1
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implmented in the contract, its respective branch will be "NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
int 6
*
txn OnCompletion
+
switch call_NoOp call_OptIn call_CloseOut NOT_IMPLEMENTED call_UpdateApplication call_DeleteApplication create_NoOp NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED

NOT_IMPLEMENTED:
	err

// onlyOwner(): void
//
// Assert the transaction sender is the owner of the contract.
onlyOwner:
	proto 0 0

	// src/roles/Ownable.algo.ts:55
	// assert(this.txn.sender === this._owner.value)
	txn Sender
	byte 0x5f6f776e6572 // "_owner"
	app_global_get
	==
	assert
	retsub

// isOwner(): boolean
//
// Checks if the current transaction sender is the owner.
// @returns {boolean} True if the sender is the owner, false otherwise.
isOwner:
	proto 0 1

	// src/roles/Ownable.algo.ts:63
	// return this.txn.sender === this._owner.value;
	txn Sender
	byte 0x5f6f776e6572 // "_owner"
	app_global_get
	==
	retsub

// owner()address
abi_route_owner:
	// The ABI return prefix
	byte 0x151f7c75

	// execute owner()address
	callsub owner
	concat
	log
	int 1
	return

// owner(): Address
owner:
	proto 0 1

	// src/roles/Ownable.algo.ts:70
	// return this._owner.value;
	byte 0x5f6f776e6572 // "_owner"
	app_global_get
	retsub

// _transferOwnership(newOwner: Address): void
//
// Transfers the ownership of the contract to a new owner.
// @param newOwner The address of the new owner.
_transferOwnership:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/roles/Ownable.algo.ts:80
	// previousOwner = this._owner.exists ? this._owner.value : globals.zeroAddress
	txna Applications 0
	byte 0x5f6f776e6572 // "_owner"
	app_global_get_ex
	swap
	pop
	bz ternary1_false
	byte 0x5f6f776e6572 // "_owner"
	app_global_get
	b ternary1_end

ternary1_false:
	global ZeroAddress

ternary1_end:
	frame_bury 0 // previousOwner: address

	// src/roles/Ownable.algo.ts:81
	// this._owner.value = newOwner
	byte 0x5f6f776e6572 // "_owner"
	frame_dig -1 // newOwner: Address
	app_global_put

	// src/roles/Ownable.algo.ts:83
	// this.OwnershipTransferred.log({
	//             previousOwner: previousOwner,
	//             newOwner: newOwner
	//         })
	byte 0x9a223efb // OwnershipTransferred(address,address)
	frame_dig 0 // previousOwner: address
	frame_dig -1 // newOwner: Address
	concat
	concat
	log
	retsub

// transferOwnership(address)void
abi_route_transferOwnership:
	// newOwner: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute transferOwnership(address)void
	callsub transferOwnership
	int 1
	return

// transferOwnership(newOwner: Address): void
//
// Transfers the ownership of the contract to a new owner.
// Requires the caller to be the current owner.
//
// @param newOwner The address of the new owner.
transferOwnership:
	proto 1 0

	// src/roles/Ownable.algo.ts:98
	// assert(this.isOwner())
	callsub isOwner
	assert

	// src/roles/Ownable.algo.ts:100
	// this._transferOwnership(newOwner)
	frame_dig -1 // newOwner: Address
	callsub _transferOwnership
	retsub

// isDepositor(fundingChannel: string, card: Address): boolean
//
// Check if the current transaction sender is the depositor of the card account
// @param card Address to check
// @returns True if the sender is the depositor of the card
isDepositor:
	proto 2 1

	// src/Immersve.algo.ts:124
	// return this.cards({fundingChannel: fundingChannel, depositor: this.txn.sender} as FundingSource).value === card;
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x0022 // initial head offset
	frame_dig -1 // fundingChannel: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub process_dynamic_tuple_element
	txn Sender
	callsub process_static_tuple_element
	pop // pop head offset
	concat // concat head and tail
	box_get
	assert
	frame_dig -2 // card: Address
	==
	retsub

// deploy()void
abi_route_deploy:
	// execute deploy()void
	callsub deploy
	int 1
	return

// deploy(): void
//
// Deploy the smart contract, setting the transaction sender as the owner
deploy:
	proto 0 0

	// src/Immersve.algo.ts:134
	// this._transferOwnership(this.txn.sender)
	txn Sender
	callsub _transferOwnership
	retsub

// update()void
abi_route_update:
	// execute update()void
	callsub update
	int 1
	return

// update(): void
//
// Allows the owner to update the smart contract
update:
	proto 0 0

	// src/Immersve.algo.ts:142
	// this.onlyOwner()
	callsub onlyOwner
	retsub

// destroy()void
abi_route_destroy:
	// execute destroy()void
	callsub destroy
	int 1
	return

// destroy(): void
//
// Destroy the smart contract, sending all Algo to the owner account. This can only be done if there are no active cards
destroy:
	proto 0 0

	// src/Immersve.algo.ts:150
	// this.onlyOwner()
	callsub onlyOwner

	// src/Immersve.algo.ts:153
	// assert(!this.active_cards.value)
	byte 0x63 // "c"
	app_global_get
	!
	assert

	// src/Immersve.algo.ts:155
	// sendPayment({
	//             receiver: this.app.address,
	//             amount: 0,
	//             closeRemainderTo: this.owner(),
	//         })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// src/Immersve.algo.ts:156
	// receiver: this.app.address
	global CurrentApplicationAddress
	itxn_field Receiver

	// src/Immersve.algo.ts:157
	// amount: 0
	int 0
	itxn_field Amount

	// src/Immersve.algo.ts:158
	// closeRemainderTo: this.owner()
	callsub owner
	itxn_field CloseRemainderTo

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// setWithdrawalRounds(uint64)void
abi_route_setWithdrawalRounds:
	// rounds: uint64
	txna ApplicationArgs 1
	btoi

	// execute setWithdrawalRounds(uint64)void
	callsub setWithdrawalRounds
	int 1
	return

// setWithdrawalRounds(rounds: uint64): void
//
// Set the number of rounds a withdrawal request must wait until being withdrawn
// @param rounds New number of rounds to wait
setWithdrawalRounds:
	proto 1 0

	// src/Immersve.algo.ts:167
	// this.onlyOwner()
	callsub onlyOwner

	// src/Immersve.algo.ts:169
	// this.withdrawal_wait_time.value = rounds
	byte 0x77 // "w"
	frame_dig -1 // rounds: uint64
	app_global_put
	retsub

// cardCreate(pay,string,address)address
abi_route_cardCreate:
	// The ABI return prefix
	byte 0x151f7c75

	// depositor: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// fundingChannel: string
	txna ApplicationArgs 1
	extract 2 0

	// mbr: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==
	assert

	// execute cardCreate(pay,string,address)address
	callsub cardCreate
	concat
	log
	int 1
	return

// cardCreate(mbr: PayTxn, fundingChannel: string, depositor: Address): Address
//
// Create account. This generates a brand new account and funds the minimum balance requirement
// @param depositor Address to have control over asset withdrawals
// @returns Newly generated account used by their card
cardCreate:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/Immersve.algo.ts:178
	// this.onlyOwner()
	callsub onlyOwner

	// src/Immersve.algo.ts:180
	// verifyPayTxn(mbr, {
	//             receiver: this.app.address,
	//             amount: globals.minBalance + box_mbr,
	//         })
	// verify receiver
	frame_dig -1 // mbr: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==
	assert

	// verify amount
	frame_dig -1 // mbr: PayTxn
	gtxns Amount
	global MinBalance
	int 40900
	+
	==
	assert

	// src/Immersve.algo.ts:186
	// card_addr = sendMethodCall<[], Address>({
	//             name: "new",
	//             onCompletion: OnCompletion.DeleteApplication,
	//             approvalProgram: Card.approvalProgram(),
	//             clearStateProgram: Card.clearProgram(),
	//         })
	itxn_begin
	int appl
	itxn_field TypeEnum
	method "new()address"
	itxn_field ApplicationArgs

	// src/Immersve.algo.ts:188
	// onCompletion: OnCompletion.DeleteApplication
	int 5 // DeleteApplication
	itxn_field OnCompletion

	// src/Immersve.algo.ts:189
	// approvalProgram: Card.approvalProgram()
	byte b64 CiACAQAxGBSBBgsxGQiNDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJwCABBUffHWIAARQsCJDigABsSKyEDIKsgcjsggyDrIgI7IBszIKiYAEVh0v6jYaAI4B/80A
	itxn_field ApprovalProgram

	// src/Immersve.algo.ts:190
	// clearStateProgram: Card.clearProgram()
	byte b64 Cg==
	itxn_field ClearStateProgram

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	int 1
	-
	itxnas Logs
	extract 4 0
	frame_bury 0 // card_addr: address

	// src/Immersve.algo.ts:194
	// sendPayment({
	//             receiver: card_addr,
	//             amount: globals.minBalance,
	//         })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// src/Immersve.algo.ts:195
	// receiver: card_addr
	frame_dig 0 // card_addr: address
	itxn_field Receiver

	// src/Immersve.algo.ts:196
	// amount: globals.minBalance
	global MinBalance
	itxn_field Amount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/Immersve.algo.ts:200
	// this.cards({fundingChannel: fundingChannel, depositor: depositor} as FundingSource).value = card_addr
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x0022 // initial head offset
	frame_dig -2 // fundingChannel: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub process_dynamic_tuple_element
	frame_dig -3 // depositor: Address
	callsub process_static_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_dig 0 // card_addr: address
	box_put

	// src/Immersve.algo.ts:203
	// this.active_cards.value = this.active_cards.value + 1
	byte 0x63 // "c"
	dup
	app_global_get
	int 1
	+
	app_global_put

	// src/Immersve.algo.ts:206
	// return card_addr;
	frame_dig 0 // card_addr: address

	// set the subroutine return value
	frame_bury 0
	retsub

// cardClose(string,address,address)void
abi_route_cardClose:
	// card: address
	txna ApplicationArgs 3
	dup
	len
	int 32
	==
	assert

	// depositor: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// fundingChannel: string
	txna ApplicationArgs 1
	extract 2 0

	// execute cardClose(string,address,address)void
	callsub cardClose
	int 1
	return

// cardClose(fundingChannel: string, depositor: Address, card: Address): void
//
// Close account. This permanently removes the rekey and deletes the account from the ledger
// @param fundingChannel Funding Channel name
// @param depositor Address which has control over asset withdrawals
// @param card Address to close
cardClose:
	proto 3 0

	// src/Immersve.algo.ts:216
	// this.onlyOwner()
	callsub onlyOwner

	// src/Immersve.algo.ts:218
	// sendPayment({
	//             sender: card,
	//             receiver: card,
	//             amount: 0,
	//             closeRemainderTo: this.txn.sender,
	//         })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// src/Immersve.algo.ts:219
	// sender: card
	frame_dig -3 // card: Address
	itxn_field Sender

	// src/Immersve.algo.ts:220
	// receiver: card
	frame_dig -3 // card: Address
	itxn_field Receiver

	// src/Immersve.algo.ts:221
	// amount: 0
	int 0
	itxn_field Amount

	// src/Immersve.algo.ts:222
	// closeRemainderTo: this.txn.sender
	txn Sender
	itxn_field CloseRemainderTo

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/Immersve.algo.ts:225
	// sendPayment({
	//             receiver: this.txn.sender,
	//             amount: box_mbr,
	//         })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// src/Immersve.algo.ts:226
	// receiver: this.txn.sender
	txn Sender
	itxn_field Receiver

	// src/Immersve.algo.ts:227
	// amount: box_mbr
	int 40900
	itxn_field Amount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/Immersve.algo.ts:231
	// this.cards({fundingChannel: fundingChannel, depositor: depositor} as FundingSource).delete()
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x0022 // initial head offset
	frame_dig -1 // fundingChannel: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub process_dynamic_tuple_element
	frame_dig -2 // depositor: Address
	callsub process_static_tuple_element
	pop // pop head offset
	concat // concat head and tail
	box_del

	// src/Immersve.algo.ts:234
	// this.active_cards.value = this.active_cards.value - 1
	byte 0x63 // "c"
	dup
	app_global_get
	int 1
	-
	app_global_put
	retsub

// allowAsset(pay,asset)void
abi_route_allowAsset:
	// asset: asset
	txna ApplicationArgs 1
	btoi
	txnas Assets

	// mbr: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==
	assert

	// execute allowAsset(pay,asset)void
	callsub allowAsset
	int 1
	return

// allowAsset(mbr: PayTxn, asset: Asset): void
allowAsset:
	proto 2 0

	// src/Immersve.algo.ts:238
	// this.onlyOwner()
	callsub onlyOwner

	// src/Immersve.algo.ts:240
	// verifyPayTxn(mbr, {
	//             receiver: this.app.address,
	//             amount: globals.assetOptInMinBalance,
	//         })
	// verify receiver
	frame_dig -1 // mbr: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==
	assert

	// verify amount
	frame_dig -1 // mbr: PayTxn
	gtxns Amount
	global AssetOptInMinBalance
	==
	assert

	// src/Immersve.algo.ts:245
	// sendAssetTransfer({
	//             sender: this.app.address,
	//             assetReceiver: this.app.address,
	//             xferAsset: asset,
	//             assetAmount: 0,
	//         })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// src/Immersve.algo.ts:246
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// src/Immersve.algo.ts:247
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// src/Immersve.algo.ts:248
	// xferAsset: asset
	frame_dig -2 // asset: Asset
	itxn_field XferAsset

	// src/Immersve.algo.ts:249
	// assetAmount: 0
	int 0
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// revokeAsset(asset)void
abi_route_revokeAsset:
	// asset: asset
	txna ApplicationArgs 1
	btoi
	txnas Assets

	// execute revokeAsset(asset)void
	callsub revokeAsset
	int 1
	return

// revokeAsset(asset: Asset): void
revokeAsset:
	proto 1 0

	// src/Immersve.algo.ts:254
	// this.onlyOwner()
	callsub onlyOwner

	// src/Immersve.algo.ts:257
	// sendAssetTransfer({
	//             sender: this.app.address,
	//             assetReceiver: this.app.address,
	//             assetCloseTo: this.app.address,
	//             xferAsset: asset,
	//             assetAmount: 0,
	//         })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// src/Immersve.algo.ts:258
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// src/Immersve.algo.ts:259
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// src/Immersve.algo.ts:260
	// assetCloseTo: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetCloseTo

	// src/Immersve.algo.ts:261
	// xferAsset: asset
	frame_dig -1 // asset: Asset
	itxn_field XferAsset

	// src/Immersve.algo.ts:262
	// assetAmount: 0
	int 0
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/Immersve.algo.ts:265
	// sendPayment({
	//             sender: this.app.address,
	//             receiver: this.txn.sender,
	//             amount: globals.assetOptInMinBalance,
	//         })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// src/Immersve.algo.ts:266
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// src/Immersve.algo.ts:267
	// receiver: this.txn.sender
	txn Sender
	itxn_field Receiver

	// src/Immersve.algo.ts:268
	// amount: globals.assetOptInMinBalance
	global AssetOptInMinBalance
	itxn_field Amount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// cardAddAsset(pay,string,address,asset)void
abi_route_cardAddAsset:
	// asset: asset
	txna ApplicationArgs 3
	btoi
	txnas Assets

	// card: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// fundingChannel: string
	txna ApplicationArgs 1
	extract 2 0

	// mbr: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==
	assert

	// execute cardAddAsset(pay,string,address,asset)void
	callsub cardAddAsset
	int 1
	return

// cardAddAsset(mbr: PayTxn, fundingChannel: string, card: Address, asset: Asset): void
//
// Allows the depositor (or owner) to OptIn to an asset, increasing the minimum balance requirement of the account
// @param fundingChannel Funding Channel name
// @param card Address to add asset to
// @param asset Asset to add
cardAddAsset:
	proto 4 0

	// src/Immersve.algo.ts:279
	// assert(this.isOwner() || this.isDepositor(fundingChannel, card))
	callsub isOwner
	dup
	bnz skip_or0
	frame_dig -3 // card: Address
	frame_dig -2 // fundingChannel: string
	callsub isDepositor
	||

skip_or0:
	assert

	// src/Immersve.algo.ts:281
	// assert(this.app.address.isOptedInToAsset(asset))
	global CurrentApplicationAddress
	frame_dig -4 // asset: Asset
	asset_holding_get AssetBalance
	swap
	pop
	assert

	// src/Immersve.algo.ts:283
	// verifyPayTxn(mbr, {
	//             receiver: this.app.address,
	//             amount: globals.assetOptInMinBalance,
	//         })
	// verify receiver
	frame_dig -1 // mbr: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==
	assert

	// verify amount
	frame_dig -1 // mbr: PayTxn
	gtxns Amount
	global AssetOptInMinBalance
	==
	assert

	// src/Immersve.algo.ts:288
	// sendPayment({
	//             receiver: card,
	//             amount: globals.assetOptInMinBalance,
	//         })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// src/Immersve.algo.ts:289
	// receiver: card
	frame_dig -3 // card: Address
	itxn_field Receiver

	// src/Immersve.algo.ts:290
	// amount: globals.assetOptInMinBalance
	global AssetOptInMinBalance
	itxn_field Amount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/Immersve.algo.ts:293
	// sendAssetTransfer({
	//             sender: card,
	//             assetReceiver: card,
	//             xferAsset: asset,
	//             assetAmount: 0,
	//         })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// src/Immersve.algo.ts:294
	// sender: card
	frame_dig -3 // card: Address
	itxn_field Sender

	// src/Immersve.algo.ts:295
	// assetReceiver: card
	frame_dig -3 // card: Address
	itxn_field AssetReceiver

	// src/Immersve.algo.ts:296
	// xferAsset: asset
	frame_dig -4 // asset: Asset
	itxn_field XferAsset

	// src/Immersve.algo.ts:297
	// assetAmount: 0
	int 0
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// cardRemoveAsset(string,address,asset)void
abi_route_cardRemoveAsset:
	// asset: asset
	txna ApplicationArgs 3
	btoi
	txnas Assets

	// card: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// fundingChannel: string
	txna ApplicationArgs 1
	extract 2 0

	// execute cardRemoveAsset(string,address,asset)void
	callsub cardRemoveAsset
	int 1
	return

// cardRemoveAsset(fundingChannel: string, card: Address, asset: Asset): void
//
// Allows the depositor (or owner) to CloseOut of an asset, reducing the minimum balance requirement of the account
// @param fundingChannel Funding Channel name
// @param card Address to remove asset from
// @param asset Asset to remove
cardRemoveAsset:
	proto 3 0

	// src/Immersve.algo.ts:308
	// assert(this.isOwner() || this.isDepositor(fundingChannel, card))
	callsub isOwner
	dup
	bnz skip_or1
	frame_dig -2 // card: Address
	frame_dig -1 // fundingChannel: string
	callsub isDepositor
	||

skip_or1:
	assert

	// src/Immersve.algo.ts:310
	// sendAssetTransfer({
	//             sender: card,
	//             assetReceiver: card,
	//             assetCloseTo: card,
	//             xferAsset: asset,
	//             assetAmount: 0,
	//         })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// src/Immersve.algo.ts:311
	// sender: card
	frame_dig -2 // card: Address
	itxn_field Sender

	// src/Immersve.algo.ts:312
	// assetReceiver: card
	frame_dig -2 // card: Address
	itxn_field AssetReceiver

	// src/Immersve.algo.ts:313
	// assetCloseTo: card
	frame_dig -2 // card: Address
	itxn_field AssetCloseTo

	// src/Immersve.algo.ts:314
	// xferAsset: asset
	frame_dig -3 // asset: Asset
	itxn_field XferAsset

	// src/Immersve.algo.ts:315
	// assetAmount: 0
	int 0
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/Immersve.algo.ts:318
	// sendPayment({
	//             sender: card,
	//             receiver: this.txn.sender,
	//             amount: globals.assetOptInMinBalance,
	//         })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// src/Immersve.algo.ts:319
	// sender: card
	frame_dig -2 // card: Address
	itxn_field Sender

	// src/Immersve.algo.ts:320
	// receiver: this.txn.sender
	txn Sender
	itxn_field Receiver

	// src/Immersve.algo.ts:321
	// amount: globals.assetOptInMinBalance
	global AssetOptInMinBalance
	itxn_field Amount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// cardDebit(address,asset,uint64)void
abi_route_cardDebit:
	// amount: uint64
	txna ApplicationArgs 3
	btoi

	// asset: asset
	txna ApplicationArgs 2
	btoi
	txnas Assets

	// card: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute cardDebit(address,asset,uint64)void
	callsub cardDebit
	int 1
	return

// cardDebit(card: Address, asset: Asset, amount: uint64): void
//
// Debits the specified amount of the given asset from the card account.
// Only the owner of the contract can perform this operation.
//
// @param card The card account from which the asset will be debited.
// @param asset The asset to be debited.
// @param amount The amount of the asset to be debited.
cardDebit:
	proto 3 0

	// src/Immersve.algo.ts:334
	// this.onlyOwner()
	callsub onlyOwner

	// src/Immersve.algo.ts:336
	// sendAssetTransfer({
	//             sender: card,
	//             assetReceiver: this.app.address,
	//             xferAsset: asset,
	//             assetAmount: amount,
	//         })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// src/Immersve.algo.ts:337
	// sender: card
	frame_dig -1 // card: Address
	itxn_field Sender

	// src/Immersve.algo.ts:338
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// src/Immersve.algo.ts:339
	// xferAsset: asset
	frame_dig -2 // asset: Asset
	itxn_field XferAsset

	// src/Immersve.algo.ts:340
	// assetAmount: amount
	frame_dig -3 // amount: uint64
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/Immersve.algo.ts:343
	// this.Debit.log({
	//             fundingSource: card,
	//             asset: asset,
	//             amount: amount,
	//         })
	byte 0x6e40a4c4 // Debit(address,uint64,uint64)
	frame_dig -1 // card: Address
	frame_dig -2 // asset: Asset
	itob
	concat
	frame_dig -3 // amount: uint64
	itob
	concat
	concat
	log
	retsub

// cardRefund(address,asset,uint64)void
abi_route_cardRefund:
	// amount: uint64
	txna ApplicationArgs 3
	btoi

	// asset: asset
	txna ApplicationArgs 2
	btoi
	txnas Assets

	// card: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute cardRefund(address,asset,uint64)void
	callsub cardRefund
	int 1
	return

// cardRefund(card: Address, asset: Asset, amount: uint64): void
//
// Refunds a specified amount of an asset to a card account.
// Only the owner of the contract can perform this operation.
//
// @param card - The card account to refund the asset to.
// @param asset - The asset to refund.
// @param amount - The amount of the asset to refund.
cardRefund:
	proto 3 0

	// src/Immersve.algo.ts:359
	// this.onlyOwner()
	callsub onlyOwner

	// src/Immersve.algo.ts:361
	// sendAssetTransfer({
	//             sender: this.app.address,
	//             assetReceiver: card,
	//             xferAsset: asset,
	//             assetAmount: amount,
	//         })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// src/Immersve.algo.ts:362
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// src/Immersve.algo.ts:363
	// assetReceiver: card
	frame_dig -1 // card: Address
	itxn_field AssetReceiver

	// src/Immersve.algo.ts:364
	// xferAsset: asset
	frame_dig -2 // asset: Asset
	itxn_field XferAsset

	// src/Immersve.algo.ts:365
	// assetAmount: amount
	frame_dig -3 // amount: uint64
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/Immersve.algo.ts:368
	// this.Refund.log({
	//             fundingSource: card,
	//             asset: asset,
	//             amount: amount,
	//         })
	byte 0xf4f52ad3 // Refund(address,uint64,uint64)
	frame_dig -1 // card: Address
	frame_dig -2 // asset: Asset
	itob
	concat
	frame_dig -3 // amount: uint64
	itob
	concat
	concat
	log
	retsub

// settle(address,asset,uint64)void
abi_route_settle:
	// amount: uint64
	txna ApplicationArgs 3
	btoi

	// asset: asset
	txna ApplicationArgs 2
	btoi
	txnas Assets

	// recipient: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute settle(address,asset,uint64)void
	callsub settle
	int 1
	return

// settle(recipient: Address, asset: Asset, amount: uint64): void
//
// Settles a payment by transferring an asset to the specified recipient.
// Only the owner of the contract can call this function.
//
// @param recipient The address of the recipient.
// @param asset The asset to be transferred.
// @param amount The amount of the asset to be transferred.
settle:
	proto 3 0

	// src/Immersve.algo.ts:384
	// this.onlyOwner()
	callsub onlyOwner

	// src/Immersve.algo.ts:386
	// sendAssetTransfer({
	//             sender: this.app.address,
	//             assetReceiver: recipient,
	//             xferAsset: asset,
	//             assetAmount: amount,
	//         })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// src/Immersve.algo.ts:387
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// src/Immersve.algo.ts:388
	// assetReceiver: recipient
	frame_dig -1 // recipient: Address
	itxn_field AssetReceiver

	// src/Immersve.algo.ts:389
	// xferAsset: asset
	frame_dig -2 // asset: Asset
	itxn_field XferAsset

	// src/Immersve.algo.ts:390
	// assetAmount: amount
	frame_dig -3 // amount: uint64
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/Immersve.algo.ts:393
	// this.Settlement.log({
	//             asset: asset,
	//             amount: amount,
	//         })
	byte 0x8b66e589 // Settlement(uint64,uint64)
	frame_dig -2 // asset: Asset
	itob
	frame_dig -3 // amount: uint64
	itob
	concat
	concat
	log
	retsub

// cardWithdrawalRequest(string,address,asset,uint64)byte[32]
abi_route_cardWithdrawalRequest:
	// The ABI return prefix
	byte 0x151f7c75

	// amount: uint64
	txna ApplicationArgs 4
	btoi

	// asset: asset
	txna ApplicationArgs 3
	btoi
	txnas Assets

	// card: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// fundingChannel: string
	txna ApplicationArgs 1
	extract 2 0

	// execute cardWithdrawalRequest(string,address,asset,uint64)byte[32]
	callsub cardWithdrawalRequest
	concat
	log
	int 1
	return

// cardWithdrawalRequest(fundingChannel: string, card: Address, asset: Asset, amount: uint64): bytes32
//
// Allows the depositor to send an amount of assets from the account
// @param fundingChannel Funding Channel name
// @param card Address to withdraw from
// @param asset Asset being withdrawn
// @param amount Amount to withdraw
// @returns Withdrawal hash used for completing or cancelling the withdrawal
cardWithdrawalRequest:
	proto 4 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// src/Immersve.algo.ts:410
	// assert(this.isDepositor(fundingChannel, card))
	frame_dig -2 // card: Address
	frame_dig -1 // fundingChannel: string
	callsub isDepositor
	assert

	// src/Immersve.algo.ts:412
	// withdrawal: WithdrawalRequest = {
	//             nonce: this.withdrawal_nonce(this.txn.sender).value,
	//             round: globals.round + this.withdrawal_wait_time.value,
	//             asset: asset,
	//             amount: amount,
	//         }
	txn Sender
	byte 0x6e // "n"
	app_local_get
	itob
	global Round
	byte 0x77 // "w"
	app_global_get
	+
	itob
	concat
	frame_dig -3 // asset: Asset
	itob
	concat
	frame_dig -4 // amount: uint64
	itob
	concat
	frame_bury 0 // withdrawal: WithdrawalRequest

	// src/Immersve.algo.ts:418
	// this.withdrawal_nonce(this.txn.sender).value = this.withdrawal_nonce(this.txn.sender).value + 1
	txn Sender
	byte 0x6e // "n"
	txn Sender
	byte 0x6e // "n"
	app_local_get
	int 1
	+
	app_local_put

	// src/Immersve.algo.ts:419
	// withdrawal_hash = sha256(rawBytes(withdrawal))
	frame_dig 0 // withdrawal: WithdrawalRequest
	sha256
	frame_bury 1 // withdrawal_hash: byte[32]

	// src/Immersve.algo.ts:421
	// this.withdrawals(
	//             this.txn.sender,
	//             withdrawal_hash,
	//         ).value = withdrawal
	txn Sender
	frame_dig 1 // withdrawal_hash: byte[32]
	frame_dig 0 // withdrawal: WithdrawalRequest
	app_local_put

	// src/Immersve.algo.ts:426
	// return withdrawal_hash;
	frame_dig 1 // withdrawal_hash: byte[32]

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// cardWithdrawalCancel(string,address,byte[32])void
abi_route_cardWithdrawalCancel:
	// withdrawal_hash: byte[32]
	txna ApplicationArgs 3
	dup
	len
	int 32
	==
	assert

	// card: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// fundingChannel: string
	txna ApplicationArgs 1
	extract 2 0

	// execute cardWithdrawalCancel(string,address,byte[32])void
	callsub cardWithdrawalCancel
	int 1
	return

// cardWithdrawalCancel(fundingChannel: string, card: Address, withdrawal_hash: bytes32): void
//
// Allows the depositor (or owner) to cancel a withdrawal request
// @param fundingChannel Funding Channel name
// @param card Address to withdraw from
// @param withdrawal_hash Hash of the withdrawal request
cardWithdrawalCancel:
	proto 3 0

	// src/Immersve.algo.ts:436
	// assert(this.isOwner() || this.isDepositor(fundingChannel, card))
	callsub isOwner
	dup
	bnz skip_or2
	frame_dig -2 // card: Address
	frame_dig -1 // fundingChannel: string
	callsub isDepositor
	||

skip_or2:
	assert

	// src/Immersve.algo.ts:438
	// this.withdrawals(this.txn.sender, withdrawal_hash).delete()
	txn Sender
	frame_dig -3 // withdrawal_hash: bytes32
	app_local_del
	retsub

// cardWithdraw(string,address,address,asset,byte[32])void
abi_route_cardWithdraw:
	// withdrawal_hash: byte[32]
	txna ApplicationArgs 5
	dup
	len
	int 32
	==
	assert

	// asset: asset
	txna ApplicationArgs 4
	btoi
	txnas Assets

	// recipient: address
	txna ApplicationArgs 3
	dup
	len
	int 32
	==
	assert

	// card: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// fundingChannel: string
	txna ApplicationArgs 1
	extract 2 0

	// execute cardWithdraw(string,address,address,asset,byte[32])void
	callsub cardWithdraw
	int 1
	return

// cardWithdraw(fundingChannel: string, card: Address, recipient: Address, asset: Asset, withdrawal_hash: bytes32): void
//
// Allows the depositor to send an amount of assets from the account
// @param fundingChannel Funding Channel name
// @param card Address to withdraw from
// @param recipient Receiver of the assets being withdrawn
// @param asset Asset being withdrawn
// @param withdrawal_hash Hash of the withdrawal request
cardWithdraw:
	proto 5 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// src/Immersve.algo.ts:452
	// assert(this.isDepositor(fundingChannel, card))
	frame_dig -2 // card: Address
	frame_dig -1 // fundingChannel: string
	callsub isDepositor
	assert

	// src/Immersve.algo.ts:454
	// withdrawal = this.withdrawals(this.txn.sender, withdrawal_hash).value
	frame_dig -5 // withdrawal_hash: bytes32
	frame_bury 0 // storage key//withdrawal

	// src/Immersve.algo.ts:454
	// withdrawal = this.withdrawals(this.txn.sender, withdrawal_hash).value
	txn Sender
	frame_bury 1 // storage account//withdrawal

	// src/Immersve.algo.ts:456
	// assert(globals.round >= withdrawal.round)
	global Round
	frame_dig 1 // storage account//withdrawal
	frame_dig 0 // storage key//withdrawal
	app_local_get
	extract 8 8
	btoi
	>=
	assert

	// src/Immersve.algo.ts:458
	// sendAssetTransfer({
	//             sender: card,
	//             assetReceiver: recipient,
	//             xferAsset: withdrawal.asset,
	//             assetAmount: withdrawal.amount,
	//         })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// src/Immersve.algo.ts:459
	// sender: card
	frame_dig -2 // card: Address
	itxn_field Sender

	// src/Immersve.algo.ts:460
	// assetReceiver: recipient
	frame_dig -3 // recipient: Address
	itxn_field AssetReceiver

	// src/Immersve.algo.ts:461
	// xferAsset: withdrawal.asset
	frame_dig 1 // storage account//withdrawal
	frame_dig 0 // storage key//withdrawal
	app_local_get
	extract 16 8
	btoi
	itxn_field XferAsset

	// src/Immersve.algo.ts:462
	// assetAmount: withdrawal.amount
	frame_dig 1 // storage account//withdrawal
	frame_dig 0 // storage key//withdrawal
	app_local_get
	extract 24 8
	btoi
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/Immersve.algo.ts:465
	// this.withdrawals(this.txn.sender, withdrawal_hash).delete()
	txn Sender
	frame_dig -5 // withdrawal_hash: bytes32
	app_local_del
	retsub

create_NoOp:
	method "deploy()void"
	txna ApplicationArgs 0
	match abi_route_deploy
	err

call_NoOp:
	method "owner()address"
	method "transferOwnership(address)void"
	method "setWithdrawalRounds(uint64)void"
	method "cardCreate(pay,string,address)address"
	method "cardClose(string,address,address)void"
	method "allowAsset(pay,asset)void"
	method "revokeAsset(asset)void"
	method "cardAddAsset(pay,string,address,asset)void"
	method "cardRemoveAsset(string,address,asset)void"
	method "cardDebit(address,asset,uint64)void"
	method "cardRefund(address,asset,uint64)void"
	method "settle(address,asset,uint64)void"
	method "cardWithdrawalRequest(string,address,asset,uint64)byte[32]"
	method "cardWithdrawalCancel(string,address,byte[32])void"
	method "cardWithdraw(string,address,address,asset,byte[32])void"
	txna ApplicationArgs 0
	match abi_route_owner abi_route_transferOwnership abi_route_setWithdrawalRounds abi_route_cardCreate abi_route_cardClose abi_route_allowAsset abi_route_revokeAsset abi_route_cardAddAsset abi_route_cardRemoveAsset abi_route_cardDebit abi_route_cardRefund abi_route_settle abi_route_cardWithdrawalRequest abi_route_cardWithdrawalCancel abi_route_cardWithdraw
	err

call_OptIn:
	method "cardWithdrawalRequest(string,address,asset,uint64)byte[32]"
	txna ApplicationArgs 0
	match abi_route_cardWithdrawalRequest
	err

call_CloseOut:
	method "cardWithdraw(string,address,address,asset,byte[32])void"
	txna ApplicationArgs 0
	match abi_route_cardWithdraw
	err

call_UpdateApplication:
	method "update()void"
	txna ApplicationArgs 0
	match abi_route_update
	err

call_DeleteApplication:
	method "destroy()void"
	txna ApplicationArgs 0
	match abi_route_destroy
	err

process_static_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -1 // element
	concat
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub

process_dynamic_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -2 // head offset
	concat
	frame_bury -4 // tuple head
	frame_dig -1 // element
	dup
	len
	frame_dig -2 // head offset
	btoi
	+
	itob
	extract 6 2
	frame_bury -2 // head offset
	frame_dig -3 // tuple tail
	swap
	concat
	frame_bury -3 // tuple tail
	frame_dig -4 // tuple head
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub